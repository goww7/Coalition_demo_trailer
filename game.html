<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coalitions MVP - Interactive Globe</title>
    
    <!-- Cesium -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            height: 100%;
            font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #cesiumContainer {
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Trailer animations */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(15, 25, 45, 0.9) 50%, rgba(0, 102, 255, 0.8) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(1.1);
        }

        .loading-title {
            font-size: clamp(3rem, 8vw, 5rem);
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #ffffff, #5AC8FA, #007AFF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .loading-subtitle {
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 2rem;
        }

        .loading-progress {
            width: 400px;
            max-width: 80vw;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #5AC8FA, #007AFF);
            width: 0%;
            transition: width 0.5s ease;
        }

        .loading-text {
            color: #ccc;
            text-align: center;
        }

        .loading-features {
            margin-top: 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            max-width: 800px;
        }

        .loading-feature {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .loading-feature-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .loading-feature-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Navigation */
        .return-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(90, 200, 250, 0.9) 0%, rgba(0, 122, 255, 1) 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 24px;
            font-weight: 600;
            text-decoration: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .return-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(90, 200, 250, 0.4);
        }

        .satellite-button {
            position: fixed;
            top: 20px;
            left: 250px;
            background: linear-gradient(135deg, rgba(255, 68, 68, 0.9) 0%, rgba(200, 0, 0, 1) 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 24px;
            font-weight: 600;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .satellite-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(255, 68, 68, 0.4);
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(90, 200, 250, 0.4);
            border-radius: 12px;
            padding: 15px 20px;
            max-width: 350px;
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.4s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification-title {
            font-weight: 600;
            color: #5AC8FA;
            margin-bottom: 5px;
        }

        .notification-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-header">
            <h1 class="loading-title">COALITIONS</h1>
            <p class="loading-subtitle">Advanced Military Simulation</p>
        </div>
        
            <div class="loading-progress">
                <div class="loading-bar" id="loadingBar"></div>
            </div>
        <p class="loading-text" id="loadingText">Initializing systems...</p>

        <div class="loading-features">
            <div class="loading-feature">
                <div class="loading-feature-icon">üéñÔ∏è</div>
                <div class="loading-feature-text">Military Simulation</div>
            </div>
            <div class="loading-feature">
                <div class="loading-feature-icon">üí•</div>
                <div class="loading-feature-text">Realtime Effects</div>
            </div>
            <div class="loading-feature">
                <div class="loading-feature-icon">üå¶Ô∏è</div>
                <div class="loading-feature-text">Weather Systems</div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <a href="index.html" class="return-button">‚Üê NASA Earth Landing</a>
    <button class="satellite-button" id="satelliteModeBtn">üõ∞Ô∏è Satellite Mode</button>

    <!-- Notification -->
    <div class="notification" id="notification">
        <div class="notification-title" id="notificationTitle"></div>
        <div class="notification-text" id="notificationText"></div>
    </div>

    <!-- Cesium Container -->
    <div id="cesiumContainer"></div>

    <!-- Clean Script -->
    <script type="module">
        // Trailer mode detection
        const isTrailerMode = new URLSearchParams(window.location.search).get('trailer') === '1';
        
        let viewer;
        let isLoading = true;
        
        // Loading steps
        const loadingSteps = [
            { text: 'Loading Cesium 3D Engine...', duration: 800 },
            { text: 'Initializing NASA Earth Imagery...', duration: 1000 },
            { text: 'Loading Military Assets...', duration: 800 },
            { text: 'Establishing Connections...', duration: 600 },
            { text: 'Final System Check...', duration: 400 }
        ];

        let currentStep = 0;
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');

        function updateLoading() {
            if (currentStep < loadingSteps.length) {
                const step = loadingSteps[currentStep];
                const progress = ((currentStep + 1) / loadingSteps.length) * 100;
                
                loadingBar.style.width = progress + '%';
                loadingText.textContent = step.text;
                
                setTimeout(() => {
                    currentStep++;
                    updateLoading();
                }, step.duration);
            } else {
                setTimeout(initializeGame, 300);
            }
        }
        
        // ADVANCED GLOBE ENRICHMENT SYSTEM
        class AdvancedGlobeEnrichment {
            constructor(viewer) {
                this.viewer = viewer;
                this.weatherSystem = null;
                this.particleSystem = null;
                this.lightingSystem = null;
                this.oceanSystem = null;
                this.isInitialized = false;
            }
            
            async initialize() {
                if (this.isInitialized) return;
                
                console.log('üåç Initializing Advanced Globe Enrichment...');
                
                // Initialize all advanced systems
                await this.initializePhotorealisticTiles();
                await this.initializeAdvancedTerrain();
                await this.initializeWeatherSystem();
                await this.initializeParticleSystem();
                await this.initializeDynamicLighting();
                await this.initializeOceanEffects();
                await this.initializePostProcessing();
                
                this.isInitialized = true;
                console.log('‚úÖ Advanced Globe Enrichment Complete!');
                
                // Show notification
                showNotification('Globe Enhanced', 'üåç Advanced visual systems activated');
            }
            
            // Google Photorealistic 3D Tiles for major cities
            async initializePhotorealisticTiles() {
                try {
                    console.log('üèôÔ∏è Loading Photorealistic 3D Tiles...');
                    
                    // Major cities with Photorealistic 3D Tiles
                    const photorealisticCities = [
                        { name: 'New York', lon: -74.006, lat: 40.7128, enabled: true },
                        { name: 'London', lon: -0.1276, lat: 51.5074, enabled: true },
                        { name: 'Paris', lon: 2.3522, lat: 48.8566, enabled: true },
                        { name: 'Tokyo', lon: 139.6917, lat: 35.6895, enabled: true },
                        { name: 'Sydney', lon: 151.2093, lat: -33.8688, enabled: true },
                        { name: 'San Francisco', lon: -122.4194, lat: 37.7749, enabled: true },
                        { name: 'Berlin', lon: 13.4050, lat: 52.5200, enabled: true },
                        { name: 'Dubai', lon: 55.2708, lat: 25.2048, enabled: true }
                    ];
                    
                    // Add Google Photorealistic 3D Tiles
                    const googleTileset = await Cesium.Cesium3DTileset.fromUrl(
                        'https://tile.googleapis.com/v1/3dtiles/root.json?key=' + this.viewer.cesiumWidget.cesiumIon.defaultAccessToken
                    );
                    
                    this.viewer.scene.primitives.add(googleTileset);
                    
                    // Style the tileset for better integration
                    googleTileset.style = new Cesium.Cesium3DTileStyle({
                        color: {
                            conditions: [
                                ['${feature["building"]} === null', 'color("white")'],
                                ['${feature["building"]} !== null', 'color("lightgray", 0.9)'],
                                ['true', 'color("white")']
                            ]
                        }
                    });
                    
                    console.log('‚úÖ Photorealistic 3D Tiles loaded');
                } catch (error) {
                    console.log('Using fallback building visualization');
                    this.createFallbackBuildings();
                }
            }
            
            // Fallback building system
            createFallbackBuildings() {
                const cities = [
                    { name: 'New York', lon: -74.006, lat: 40.7128 },
                    { name: 'London', lon: -0.1276, lat: 51.5074 },
                    { name: 'Paris', lon: 2.3522, lat: 48.8566 },
                    { name: 'Tokyo', lon: 139.6917, lat: 35.6895 }
                ];
                
                cities.forEach(city => {
                    // Create procedural city blocks
                    for (let i = 0; i < 20; i++) {
                        const offsetLon = (Math.random() - 0.5) * 0.02;
                        const offsetLat = (Math.random() - 0.5) * 0.02;
                        const height = Math.random() * 200 + 50;
                        
                        this.viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(
                                city.lon + offsetLon, 
                                city.lat + offsetLat, 
                                height / 2
                            ),
                            box: {
                                dimensions: new Cesium.Cartesian3(100, 100, height),
                                material: Cesium.Color.LIGHTGRAY.withAlpha(0.8),
                                outline: true,
                                outlineColor: Cesium.Color.DARKGRAY
                            }
                        });
                    }
                });
            }
            
            // Advanced terrain with bathymetry
            async initializeAdvancedTerrain() {
                try {
                    console.log('üèîÔ∏è Initializing Advanced Terrain...');
                    
                    // Cesium World Terrain with all features
                    const terrainProvider = await Cesium.createWorldTerrainAsync({
                        requestWaterMask: true,
                        requestVertexNormals: true,
                        requestMetadata: true
                    });
                    
                    this.viewer.terrainProvider = terrainProvider;
                    
                    // Add Cesium World Bathymetry for underwater terrain
                    const bathymetryProvider = new Cesium.CesiumTerrainProvider({
                        url: 'https://assets.cesium.com/ion/1/assets/1/tileset.json',
                        requestWaterMask: true
                    });
                    
                    // Enable terrain lighting and shadows
                    this.viewer.scene.globe.enableLighting = true;
                    this.viewer.scene.globe.dynamicAtmosphereLighting = true;
                    this.viewer.scene.globe.atmosphereLightIntensity = 10.0;
                    
                    // Enhanced water appearance
                    this.viewer.scene.globe.oceanNormalMapUrl = 'https://assets.cesium.com/ion/1/assets/1/images/normalMap.jpg';
                    this.viewer.scene.globe.showWaterEffect = true;
                    
                    // Terrain exaggeration for dramatic effect
                    this.viewer.scene.globe.terrainExaggeration = 1.5;
                    this.viewer.scene.globe.terrainExaggerationRelativeHeight = 0.0;
                    
                    console.log('‚úÖ Advanced Terrain loaded');
                } catch (error) {
                    console.log('Using basic terrain with enhancements');
                    this.enhanceBasicTerrain();
                }
            }
            
            enhanceBasicTerrain() {
                // Enhanced basic terrain settings
                this.viewer.scene.globe.enableLighting = true;
                this.viewer.scene.globe.dynamicAtmosphereLighting = true;
                this.viewer.scene.globe.showWaterEffect = true;
                this.viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#1e3d59');
            }
            
            // Weather system integration
            async initializeWeatherSystem() {
                console.log('üå¶Ô∏è Initializing Weather System...');
                
                this.weatherSystem = {
                    precipitation: null,
                    windStreams: [],
                    temperatureOverlay: null,
                    cloudLayers: []
                };
                
                // Create dynamic cloud system
                this.createCloudLayers();
                
                // Add precipitation effects
                this.createPrecipitationSystem();
                
                // Wind stream visualization
                this.createWindStreams();
                
                // Temperature overlay
                this.createTemperatureOverlay();
                
                console.log('‚úÖ Weather System initialized');
            }
            
            createCloudLayers() {
                // Dynamic cloud coverage using particle system
                const cloudPositions = [];
                const cloudColors = [];
                
                for (let i = 0; i < 1000; i++) {
                    const lon = (Math.random() - 0.5) * 360;
                    const lat = (Math.random() - 0.5) * 180;
                    const height = 8000 + Math.random() * 4000;
                    
                    cloudPositions.push(Cesium.Cartesian3.fromDegrees(lon, lat, height));
                    cloudColors.push(Cesium.Color.WHITE.withAlpha(0.6));
                }
                
                // Cloud particle system
                const cloudSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.WHITE.withAlpha(0.7),
                    endColor: Cesium.Color.WHITE.withAlpha(0.0),
                    startScale: 50.0,
                    endScale: 100.0,
                    minimumParticleLife: 5.0,
                    maximumParticleLife: 10.0,
                    minimumSpeed: 1.0,
                    maximumSpeed: 4.0,
                    imageSize: new Cesium.Cartesian2(100, 100),
                    emissionRate: 50.0,
                    lifetime: 16.0,
                    emitter: new Cesium.SphereEmitter(5000000.0)
                }));
                
                this.weatherSystem.cloudLayers.push(cloudSystem);
            }
            
            createPrecipitationSystem() {
                // Rain/snow particle system
                const precipitationSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.LIGHTBLUE.withAlpha(0.8),
                    endColor: Cesium.Color.BLUE.withAlpha(0.2),
                    startScale: 2.0,
                    endScale: 1.0,
                    minimumParticleLife: 1.0,
                    maximumParticleLife: 3.0,
                    minimumSpeed: 10.0,
                    maximumSpeed: 20.0,
                    imageSize: new Cesium.Cartesian2(2, 10),
                    emissionRate: 200.0,
                    lifetime: 16.0,
                    emitter: new Cesium.BoxEmitter(new Cesium.Cartesian3(100000, 100000, 1000))
                }));
                
                this.weatherSystem.precipitation = precipitationSystem;
            }
            
            createWindStreams() {
                // Wind flow visualization using polylines
                const windData = [
                    { start: [-120, 35], end: [-80, 40], strength: 'strong' },
                    { start: [0, 50], end: [40, 45], strength: 'moderate' },
                    { start: [100, 30], end: [140, 35], strength: 'light' },
                    { start: [-30, -20], end: [20, -15], strength: 'strong' }
                ];
                
                windData.forEach(wind => {
                    const positions = [];
                    const colors = [];
                    const steps = 20;
                    
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const lon = Cesium.Math.lerp(wind.start[0], wind.end[0], t);
                        const lat = Cesium.Math.lerp(wind.start[1], wind.end[1], t) + Math.sin(t * Math.PI * 4) * 2;
                        const height = 5000 + Math.sin(t * Math.PI * 2) * 2000;
                        
                        positions.push(Cesium.Cartesian3.fromDegrees(lon, lat, height));
                        
                        const alpha = wind.strength === 'strong' ? 0.8 : wind.strength === 'moderate' ? 0.6 : 0.4;
                        colors.push(Cesium.Color.CYAN.withAlpha(alpha));
                    }
                    
                    const windStream = this.viewer.entities.add({
                        polyline: {
                            positions: positions,
                            width: wind.strength === 'strong' ? 8 : wind.strength === 'moderate' ? 5 : 3,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.2,
                                color: Cesium.Color.CYAN.withAlpha(0.7)
                            }),
                            clampToGround: false,
                            height: 1000
                        }
                    });
                    
                    this.weatherSystem.windStreams.push(windStream);
                });
            }
            
            createTemperatureOverlay() {
                // Temperature visualization using color-coded regions
                const temperatureRegions = [
                    { bounds: [-180, -60, 180, -30], temp: -10, color: Cesium.Color.BLUE },
                    { bounds: [-180, -30, 180, 0], temp: 15, color: Cesium.Color.CYAN },
                    { bounds: [-180, 0, 180, 30], temp: 25, color: Cesium.Color.YELLOW },
                    { bounds: [-180, 30, 180, 60], temp: 30, color: Cesium.Color.ORANGE },
                    { bounds: [-180, 60, 180, 90], temp: -5, color: Cesium.Color.LIGHTBLUE }
                ];
                
                temperatureRegions.forEach(region => {
                    const temperatureZone = this.viewer.entities.add({
                        rectangle: {
                            coordinates: Cesium.Rectangle.fromDegrees(
                                region.bounds[0], region.bounds[1], 
                                region.bounds[2], region.bounds[3]
                            ),
                            material: region.color.withAlpha(0.3),
                            height: 100000,
                            outline: false
                        }
                    });
                });
            }
            
            // Advanced particle systems
            async initializeParticleSystem() {
                console.log('‚ú® Initializing Advanced Particle Systems...');
                
                this.particleSystem = {
                    aurora: null,
                    cityLights: [],
                    atmosphericEffects: []
                };
                
                // Aurora Borealis effect
                this.createAuroraEffect();
                
                // City lights at night
                this.createCityLights();
                
                // Atmospheric scattering particles
                this.createAtmosphericEffects();
                
                console.log('‚úÖ Particle Systems initialized');
            }
            
            createAuroraEffect() {
                // Aurora particle system for polar regions
                const auroraSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.GREEN.withAlpha(0.8),
                    endColor: Cesium.Color.PURPLE.withAlpha(0.2),
                    startScale: 100.0,
                    endScale: 200.0,
                    minimumParticleLife: 8.0,
                    maximumParticleLife: 15.0,
                    minimumSpeed: 2.0,
                    maximumSpeed: 8.0,
                    imageSize: new Cesium.Cartesian2(50, 200),
                    emissionRate: 30.0,
                    lifetime: 20.0,
                    emitter: new Cesium.BoxEmitter(new Cesium.Cartesian3(2000000, 100000, 500000)),
                    modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
                        Cesium.Cartesian3.fromDegrees(0, 75, 200000)
                    )
                }));
                
                this.particleSystem.aurora = auroraSystem;
            }
            
            createCityLights() {
                const majorCities = [
                    { name: 'New York', lon: -74.006, lat: 40.7128 },
                    { name: 'London', lon: -0.1276, lat: 51.5074 },
                    { name: 'Tokyo', lon: 139.6917, lat: 35.6895 },
                    { name: 'Paris', lon: 2.3522, lat: 48.8566 },
                    { name: 'Sydney', lon: 151.2093, lat: -33.8688 }
                ];
                
                majorCities.forEach(city => {
                    // City glow effect
                    const cityGlow = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(city.lon, city.lat, 1000),
                        ellipse: {
                            semiMinorAxis: 50000,
                            semiMajorAxis: 50000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.3 + Math.sin(time * 0.5) * 0.2;
                                    return Cesium.Color.YELLOW.withAlpha(alpha);
                                }, false)
                            ),
                            height: 0
                        }
                    });
                    
                    this.particleSystem.cityLights.push(cityGlow);
                });
            }
            
            createAtmosphericEffects() {
                // Atmospheric haze and scattering
                const atmosphericHaze = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.WHITE.withAlpha(0.1),
                    endColor: Cesium.Color.BLUE.withAlpha(0.05),
                    startScale: 200.0,
                    endScale: 500.0,
                    minimumParticleLife: 20.0,
                    maximumParticleLife: 40.0,
                    minimumSpeed: 0.5,
                    maximumSpeed: 2.0,
                    imageSize: new Cesium.Cartesian2(200, 200),
                    emissionRate: 10.0,
                    lifetime: 60.0,
                    emitter: new Cesium.SphereEmitter(6500000.0)
                }));
                
                this.particleSystem.atmosphericEffects.push(atmosphericHaze);
            }
            
            // Dynamic lighting system
            async initializeDynamicLighting() {
                console.log('‚òÄÔ∏è Initializing Dynamic Lighting...');
                
                this.lightingSystem = {
                    sunPosition: null,
                    moonPosition: null,
                    dynamicShadows: true,
                    atmosphericScattering: true
                };
                
                // Enable advanced lighting
                this.viewer.scene.globe.enableLighting = true;
                this.viewer.scene.globe.dynamicAtmosphereLighting = true;
                this.viewer.scene.globe.atmosphereLightIntensity = 20.0;
                this.viewer.scene.globe.atmosphereHueShift = 0.1;
                this.viewer.scene.globe.atmosphereSaturationShift = 0.1;
                this.viewer.scene.globe.atmosphereBrightnessShift = 0.1;
                
                // Dynamic shadows
                this.viewer.shadows = true;
                this.viewer.terrainShadows = Cesium.ShadowMode.ENABLED;
                
                // Enhanced sky atmosphere
                this.viewer.scene.skyAtmosphere.hueShift = 0.1;
                this.viewer.scene.skyAtmosphere.saturationShift = 0.1;
                this.viewer.scene.skyAtmosphere.brightnessShift = 0.1;
                
                // Sun and moon positioning
                this.setupCelestialBodies();
                
                // Day/night cycle
                this.startDayNightCycle();
                
                console.log('‚úÖ Dynamic Lighting initialized');
            }
            
            setupCelestialBodies() {
                // Enhanced sun
                this.viewer.scene.sun.show = true;
                this.viewer.scene.sun.glowFactor = 2.0;
                
                // Enhanced moon
                this.viewer.scene.moon.show = true;
                this.viewer.scene.moon.textureUrl = 'https://assets.cesium.com/ion/1/assets/1/images/moon.jpg';
                
                // Stars
                this.viewer.scene.skyBox.show = true;
                this.viewer.scene.skyBox.sources = {
                    positiveX: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_positive_x.jpg',
                    negativeX: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_negative_x.jpg',
                    positiveY: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_positive_y.jpg',
                    negativeY: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_negative_y.jpg',
                    positiveZ: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_positive_z.jpg',
                    negativeZ: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_negative_z.jpg'
                };
            }
            
            startDayNightCycle() {
                // Accelerated day/night cycle for demo
                setInterval(() => {
                    const currentTime = this.viewer.clock.currentTime;
                    const newTime = Cesium.JulianDate.addMinutes(currentTime, 10, new Cesium.JulianDate());
                    this.viewer.clock.currentTime = newTime;
                }, 1000); // Update every second, advance 10 minutes
            }
            
            // Ocean effects system
            async initializeOceanEffects() {
                console.log('üåä Initializing Ocean Effects...');
                
                this.oceanSystem = {
                    waveAnimation: true,
                    underwaterFog: true,
                    caustics: true
                };
                
                // Enhanced ocean rendering
                this.viewer.scene.globe.showWaterEffect = true;
                this.viewer.scene.globe.oceanNormalMapUrl = 'https://assets.cesium.com/ion/1/assets/1/images/waterNormals.jpg';
                
                // Underwater fog effect
                this.viewer.scene.fog.enabled = true;
                this.viewer.scene.fog.density = 0.0002;
                this.viewer.scene.fog.screenSpaceErrorFactor = 2.0;
                
                // Ocean wave animation
                this.animateOceanWaves();
                
                // Underwater caustics simulation
                this.createUnderwaterCaustics();
                
                console.log('‚úÖ Ocean Effects initialized');
            }
            
            animateOceanWaves() {
                // Animate ocean normal map for wave effect
                let waveTime = 0;
                const animateWaves = () => {
                    waveTime += 0.01;
                    
                    // This would normally update ocean shader uniforms
                    // For demo purposes, we'll use a simple material animation
                    if (this.viewer.scene.globe.oceanNormalMapUrl) {
                        // Ocean animation would go here in a full implementation
                    }
                    
                    requestAnimationFrame(animateWaves);
                };
                animateWaves();
            }
            
            createUnderwaterCaustics() {
                // Underwater light caustics effect using entities
                const causticsPositions = [];
                for (let i = 0; i < 50; i++) {
                    const lon = (Math.random() - 0.5) * 360;
                    const lat = (Math.random() - 0.5) * 180;
                    const depth = -Math.random() * 1000 - 100;
                    
                    const caustic = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(lon, lat, depth),
                        ellipse: {
                            semiMinorAxis: Math.random() * 100 + 50,
                            semiMajorAxis: Math.random() * 100 + 50,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.2 + Math.sin(time * 2 + i) * 0.1;
                                    return Cesium.Color.CYAN.withAlpha(alpha);
                                }, false)
                            ),
                            height: depth
                        }
                    });
                    
                    causticsPositions.push(caustic);
                }
            }
            
            // Post-processing effects
            async initializePostProcessing() {
                console.log('üé® Initializing Post-Processing Effects...');
                
                // Bloom effect
                this.viewer.scene.postProcessStages.add(Cesium.PostProcessStageLibrary.createBloomStage());
                
                // Depth of field
                const depthOfField = Cesium.PostProcessStageLibrary.createDepthOfFieldStage();
                this.viewer.scene.postProcessStages.add(depthOfField);
                
                // Color grading
                const colorGrading = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        varying vec2 v_textureCoordinates;
                        
                        void main() {
                            vec4 color = texture2D(colorTexture, v_textureCoordinates);
                            
                            // Enhanced saturation and contrast
                            color.rgb = mix(vec3(dot(color.rgb, vec3(0.299, 0.587, 0.114))), color.rgb, 1.2);
                            color.rgb = pow(color.rgb, vec3(0.9));
                            
                            gl_FragColor = color;
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(colorGrading);
                
                // Atmospheric perspective
                const atmosphericPerspective = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        uniform sampler2D depthTexture;
                        varying vec2 v_textureCoordinates;
                        
                        void main() {
                            vec4 color = texture2D(colorTexture, v_textureCoordinates);
                            float depth = texture2D(depthTexture, v_textureCoordinates).r;
                            
                            // Add atmospheric haze based on depth
                            vec3 fogColor = vec3(0.7, 0.8, 1.0);
                            float fogFactor = 1.0 - exp(-depth * 0.00001);
                            color.rgb = mix(color.rgb, fogColor, fogFactor * 0.3);
                            
                            gl_FragColor = color;
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(atmosphericPerspective);
                
                console.log('‚úÖ Post-Processing Effects initialized');
            }
            
            // Toggle weather effects
            toggleWeatherEffects(enabled) {
                if (!this.weatherSystem) return;
                
                this.weatherSystem.cloudLayers.forEach(cloud => {
                    cloud.show = enabled;
                });
                
                if (this.weatherSystem.precipitation) {
                    this.weatherSystem.precipitation.show = enabled;
                }
                
                this.weatherSystem.windStreams.forEach(wind => {
                    wind.show = enabled;
                });
            }
            
            // Toggle particle effects
            toggleParticleEffects(enabled) {
                if (!this.particleSystem) return;
                
                if (this.particleSystem.aurora) {
                    this.particleSystem.aurora.show = enabled;
                }
                
                this.particleSystem.cityLights.forEach(light => {
                    light.show = enabled;
                });
                
                this.particleSystem.atmosphericEffects.forEach(effect => {
                    effect.show = enabled;
                });
            }
            
            // Toggle ocean effects
            toggleOceanEffects(enabled) {
                this.viewer.scene.globe.showWaterEffect = enabled;
                this.viewer.scene.fog.enabled = enabled;
            }
            
            // Performance optimization
            optimizeForPerformance() {
                // Reduce particle counts for better performance
                this.viewer.scene.fog.density = 0.0001;
                
                // Optimize terrain detail
                this.viewer.scene.globe.maximumScreenSpaceError = 2;
                this.viewer.scene.globe.tileCacheSize = 100;
                
                // Reduce post-processing quality
                this.viewer.scene.postProcessStages.removeAll();
                this.viewer.scene.postProcessStages.add(Cesium.PostProcessStageLibrary.createBloomStage());
                
                console.log('üöÄ Performance optimized');
            }
            
            // Enhanced coordinate validation with stricter bounds
            validateCoordinates(lon, lat) {
                // More robust longitude normalization
                while (lon > 180) lon -= 360;
                while (lon < -180) lon += 360;
                
                // Ensure we're well within bounds (add small buffer for floating point precision)
                lon = Math.max(-179.99, Math.min(179.99, lon));
                lat = Math.max(-89.99, Math.min(89.99, lat));
                
                return { lon, lat };
            }
            
            // Safe Rectangle creation with validation
            createSafeRectangle(west, south, east, north) {
                try {
                    // Validate all corners
                    const sw = this.validateCoordinates(west, south);
                    const ne = this.validateCoordinates(east, north);
                    
                    // Ensure west < east and south < north
                    const finalWest = Math.min(sw.lon, ne.lon);
                    const finalEast = Math.max(sw.lon, ne.lon);
                    const finalSouth = Math.min(sw.lat, ne.lat);
                    const finalNorth = Math.max(sw.lat, ne.lat);
                    
                    return Cesium.Rectangle.fromDegrees(finalWest, finalSouth, finalEast, finalNorth);
                } catch (error) {
                    console.warn('Rectangle creation failed, using default:', error);
                    // Return a safe default rectangle
                    return Cesium.Rectangle.fromDegrees(-1, -1, 1, 1);
                }
            }
            
            // Safe entity creation wrapper
            createSafeEntity(entityOptions) {
                try {
                    return this.viewer.entities.add(entityOptions);
                } catch (error) {
                    console.warn('Entity creation failed:', error);
                    return null;
                }
            }
            
            createStuckCargoShips(positions) {
                // Create cargo ships stuck at sea with safe coordinates
                for (let i = 0; i < positions.length - 2; i += 4) {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(positions[i], positions[i + 1]);
                        
                        const ship = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                            rectangle: {
                                coordinates: this.createSafeRectangle(
                                    coords.lon - 0.05, coords.lat - 0.02,
                                    coords.lon + 0.05, coords.lat + 0.02
                                ),
                                material: Cesium.Color.GRAY,
                                height: 0,
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create cargo ship at position ${i}:`, error);
                    }
                }
            }
            
            // Fix all functions that create rectangles or use coordinates
            createTSMCFacilities() {
                const tsmcLocations = [
                    { lon: 120.9605, lat: 24.7736, name: "Fab 18 (3nm)" },
                    { lon: 120.3397, lat: 24.1469, name: "Fab 15 (7nm)" },
                    { lon: 120.9777, lat: 24.8138, name: "Fab 12 (28nm)" }
                ];
                
                tsmcLocations.forEach((fab, i) => {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(fab.lon, fab.lat);
                        
                        // Create glowing fab facility
                        const facility = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 100),
                            box: {
                                dimensions: new Cesium.Cartesian3(500, 300, 50),
                                material: new Cesium.ColorMaterialProperty(
                                    new Cesium.CallbackProperty(() => {
                                        const time = Date.now() / 1000;
                                        const alpha = 0.7 + Math.sin(time * 2 + i) * 0.3;
                                        return Cesium.Color.CYAN.withAlpha(alpha);
                                    }, false)
                                ),
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            },
                            label: {
                                text: fab.name,
                                font: '12pt monospace',
                                fillColor: Cesium.Color.WHITE,
                                outlineColor: Cesium.Color.BLACK,
                                outlineWidth: 2,
                                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                pixelOffset: new Cesium.Cartesian2(0, -50)
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create TSMC facility ${fab.name}:`, error);
                    }
                });
            }
            
            createNavalBlockade() {
                // Chinese naval positions - validated coordinates
                const navalPositions = [
                    { lon: 119.5, lat: 25.2 }, { lon: 120.2, lat: 25.8 },
                    { lon: 121.8, lat: 24.5 }, { lon: 121.2, lat: 23.8 },
                    { lon: 119.8, lat: 23.5 }, { lon: 118.9, lat: 24.1 }
                ];
                
                navalPositions.forEach((pos, i) => {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(pos.lon, pos.lat);
                        
                        // Create naval vessels
                        const vessel = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                            ellipse: {
                                semiMinorAxis: 2000,
                                semiMajorAxis: 4000,
                                material: Cesium.Color.RED.withAlpha(0.8),
                                outline: true,
                                outlineColor: Cesium.Color.DARKRED
                            }
                        });
                        
                        // Add radar coverage circles
                        const radarCoverage = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                            ellipse: {
                                semiMinorAxis: 50000,
                                semiMajorAxis: 50000,
                                material: new Cesium.ColorMaterialProperty(
                                    new Cesium.CallbackProperty(() => {
                                        const time = Date.now() / 1000;
                                        const alpha = 0.2 + Math.sin(time * 3 + i) * 0.1;
                                        return Cesium.Color.RED.withAlpha(alpha);
                                    }, false)
                                )
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create naval vessel at position ${i}:`, error);
                    }
                });
                
                // Shipping lane blockade - fixed coordinates
                try {
                    const blockadeCoords = [
                        118.0, 22.0, 122.0, 26.0, 124.0, 24.0, 120.0, 20.0, 118.0, 22.0
                    ];
                    
                    // Validate all coordinates
                    const validatedCoords = [];
                    for (let i = 0; i < blockadeCoords.length; i += 2) {
                        const coords = this.validateCoordinates(blockadeCoords[i], blockadeCoords[i + 1]);
                        validatedCoords.push(coords.lon, coords.lat);
                    }
                    
                    const blockedShipping = this.createSafeEntity({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArray(validatedCoords),
                            width: 10,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.3,
                                color: Cesium.Color.RED
                            }),
                            clampToGround: false,
                            height: 1000
                        }
                    });
                } catch (error) {
                    console.warn('Failed to create shipping blockade:', error);
                }
            }
            
            createDisruptedShipping() {
                // Major shipping routes now blocked or delayed
                const shippingRoutes = [
                    { 
                        route: [121, 25, 140, 35, 179, 40, -150, 45, -120, 35], // Fixed to avoid 180¬∞ crossing
                        status: "blocked",
                        name: "Trans-Pacific Route"
                    },
                    { 
                        route: [121, 25, 103, 1, 80, 10, 60, 25, 45, 30], 
                        status: "delayed",
                        name: "Asia-Middle East Route"
                    },
                    { 
                        route: [121, 25, 100, -10, 80, -20, 20, -35, 0, 0], 
                        status: "rerouting",
                        name: "Asia-Europe Route"
                    }
                ];
                
                shippingRoutes.forEach(route => {
                    try {
                        // Validate all coordinates in route
                        const validatedRoute = [];
                        for (let i = 0; i < route.route.length; i += 2) {
                            const coords = this.validateCoordinates(route.route[i], route.route[i + 1]);
                            validatedRoute.push(coords.lon, coords.lat);
                        }
                        
                        const color = route.status === "blocked" ? Cesium.Color.RED :
                                     route.status === "delayed" ? Cesium.Color.ORANGE :
                                     Cesium.Color.YELLOW;
                        
                        const shippingLine = this.createSafeEntity({
                            polyline: {
                                positions: Cesium.Cartesian3.fromDegreesArray(validatedRoute),
                                width: 6,
                                material: new Cesium.PolylineGlowMaterialProperty({
                                    glowPower: 0.2,
                                    color: color.withAlpha(0.8)
                                }),
                                clampToGround: false,
                                height: 10000
                            }
                        });
                        
                        // Add animated cargo ships stuck in routes
                        if (route.status === "blocked") {
                            this.createStuckCargoShips(validatedRoute);
                        }
                    } catch (error) {
                        console.warn(`Failed to create shipping route ${route.name}:`, error);
                    }
                });
            }
            
            createSmokeEffect(position) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    // Industrial smoke/shutdown effect
                    const smokeSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                        image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                        startColor: Cesium.Color.GRAY.withAlpha(0.8),
                        endColor: Cesium.Color.BLACK.withAlpha(0.1),
                        startScale: 20.0,
                        endScale: 50.0,
                        minimumParticleLife: 3.0,
                        maximumParticleLife: 6.0,
                        minimumSpeed: 2.0,
                        maximumSpeed: 8.0,
                        imageSize: new Cesium.Cartesian2(25, 25),
                        emissionRate: 30.0,
                        lifetime: 8.0,
                        emitter: new Cesium.CircleEmitter(5000.0),
                        modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
                            Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 500)
                        )
                    }));
                    
                    // Remove after 8 seconds
                    setTimeout(() => {
                        try {
                            this.viewer.scene.primitives.remove(smokeSystem);
                        } catch (e) {
                            console.warn('Failed to remove smoke system:', e);
                        }
                    }, 8000);
                } catch (error) {
                    console.warn('Failed to create smoke effect:', error);
                }
            }
            
            createFinancialCrisis(position, type) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    const colors = {
                        market: Cesium.Color.RED,
                        currency: Cesium.Color.ORANGE,
                        banking: Cesium.Color.PURPLE,
                        central_bank: Cesium.Color.BLUE,
                        controls: Cesium.Color.YELLOW
                    };
                    
                    // Financial crisis visualization
                    const crisis = this.createSafeEntity({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                        ellipse: {
                            semiMinorAxis: 100000,
                            semiMajorAxis: 100000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.4 + Math.sin(time * 4) * 0.3;
                                    return colors[type].withAlpha(alpha);
                                }, false)
                            ),
                            outline: true,
                            outlineColor: colors[type]
                        }
                    });
                    
                    // Add pulsing effect
                    this.createPulsingEffect([coords.lon, coords.lat], colors[type]);
                } catch (error) {
                    console.warn('Failed to create financial crisis visualization:', error);
                }
            }
            
            createDataStreamAttack(targetPos) {
                try {
                    // Validate target coordinates
                    const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                    
                    // Create attack vector lines from various origins
                    const attackOrigins = [
                        [116.4074, 39.9042], // Beijing
                        [37.6176, 55.7558],  // Moscow
                        [55.2708, 25.2048]   // Dubai (proxy)
                    ];
                    
                    attackOrigins.forEach(origin => {
                        try {
                            // Validate origin coordinates
                            const originCoords = this.validateCoordinates(origin[0], origin[1]);
                            
                            const attackVector = this.createSafeEntity({
                                polyline: {
                                    positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                        originCoords.lon, originCoords.lat, 20000,
                                        targetCoords.lon, targetCoords.lat, 5000
                                    ]),
                                    width: 4,
                                    material: new Cesium.PolylineGlowMaterialProperty({
                                        glowPower: 0.3,
                                        color: Cesium.Color.MAGENTA.withAlpha(0.8)
                                    })
                                }
                            });
                        } catch (error) {
                            console.warn('Failed to create attack vector:', error);
                        }
                    });
                } catch (error) {
                    console.warn('Failed to create data stream attack:', error);
                }
            }
            
            createRefugeeCamp(position) {
                try {
                    // Validate coordinates and add small offset for camp location
                    const coords = this.validateCoordinates(position[0] + 0.1, position[1] + 0.1);
                    
                    // Refugee camp visualization
                    const camp = this.createSafeEntity({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                        ellipse: {
                            semiMinorAxis: 15000,
                            semiMajorAxis: 25000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.5 + Math.sin(time) * 0.2;
                                    return Cesium.Color.BROWN.withAlpha(alpha);
                                }, false)
                            ),
                            outline: true,
                            outlineColor: Cesium.Color.WHITE
                        }
                    });
                } catch (error) {
                    console.warn('Failed to create refugee camp:', error);
                }
            }
            
            createASATAttack(targetPos) {
                try {
                    // Anti-satellite weapon launch
                    const launchSite = [116.4074, 39.9042, 0]; // China
                    
                    // Validate launch site coordinates
                    const launchCoords = this.validateCoordinates(launchSite[0], launchSite[1]);
                    
                    // Validate target coordinates (space coordinates don't need validation but we'll be safe)
                    const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                    
                    // Missile trajectory to satellite
                    const asatMissile = this.createSafeEntity({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                launchCoords.lon, launchCoords.lat, launchSite[2],
                                targetCoords.lon, targetCoords.lat, targetPos[2]
                            ]),
                            width: 5,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.4,
                                color: Cesium.Color.RED.withAlpha(0.9)
                            })
                        }
                    });
                    
                    // Satellite explosion
                    setTimeout(() => {
                        this.createExplosion(
                            Cesium.Cartesian3.fromDegrees(targetCoords.lon, targetCoords.lat, targetPos[2]),
                            0.8
                        );
                    }, 2000);
                } catch (error) {
                    console.warn('Failed to create ASAT attack:', error);
                }
            }
            
            createPulsingEffect(position, color) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    const pulseEffect = this.createSafeEntity({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 2000),
                        ellipse: {
                            semiMinorAxis: 50000,
                            semiMajorAxis: 50000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const scale = 1 + Math.sin(time * 6) * 0.5;
                                    const alpha = 0.3 + Math.sin(time * 6) * 0.2;
                                    return color.withAlpha(alpha);
                                }, false)
                            )
                        }
                    });
                    
                    // Remove after 5 seconds
                    setTimeout(() => {
                        try {
                            if (pulseEffect) {
                                this.viewer.entities.remove(pulseEffect);
                            }
                        } catch (e) {
                            console.warn('Failed to remove pulse effect:', e);
                        }
                    }, 5000);
                } catch (error) {
                    console.warn('Failed to create pulsing effect:', error);
                }
            }
        }
        
        // Initialize advanced globe enrichment
        let advancedGlobe = null;
        
        // Enhanced initialization function
        async function initializeEnhancedGame() {
            try {
                // Initialize basic game first
                await initializeGame();
                
                // Initialize advanced globe features
                advancedGlobe = new AdvancedGlobeEnrichment(viewer);
                await advancedGlobe.initialize();
                
                // Add control panel for toggling features
                createAdvancedControlPanel();
                
                console.log('üåç Enhanced Globe Experience Ready!');
                
            } catch (error) {
                console.error('Enhanced initialization failed:', error);
                // Fallback to basic initialization
                await initializeGame();
            }
        }
        
        // Control panel for advanced features
        function createAdvancedControlPanel() {
            const controlPanel = document.createElement('div');
            controlPanel.style.cssText = `
                position: absolute; top: 100px; right: 20px; width: 250px;
                background: rgba(0,0,0,0.8); color: white; padding: 15px;
                border-radius: 10px; font-family: 'SF Pro Text', sans-serif;
                border: 1px solid #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.3);
            `;
            
            controlPanel.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #00ff88;">üåç Globe Controls</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="weather-toggle" checked>
                        <span>üå¶Ô∏è Weather Effects</span>
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="particles-toggle" checked>
                        <span>‚ú® Particle Effects</span>
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="ocean-toggle" checked>
                        <span>üåä Ocean Effects</span>
                    </label>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="performance-toggle">
                        <span>üöÄ Performance Mode</span>
                    </label>
                </div>
                <button id="reset-view" style="width: 100%; padding: 8px; background: #00ff88; border: none; border-radius: 5px; color: black; font-weight: bold;">
                    üè† Reset View
                </button>
            `;
            
            document.body.appendChild(controlPanel);
            
            // Event listeners
            document.getElementById('weather-toggle').addEventListener('change', (e) => {
                if (advancedGlobe) advancedGlobe.toggleWeatherEffects(e.target.checked);
            });
            
            document.getElementById('particles-toggle').addEventListener('change', (e) => {
                if (advancedGlobe) advancedGlobe.toggleParticleEffects(e.target.checked);
            });
            
            document.getElementById('ocean-toggle').addEventListener('change', (e) => {
                if (advancedGlobe) advancedGlobe.toggleOceanEffects(e.target.checked);
            });
            
            document.getElementById('performance-toggle').addEventListener('change', (e) => {
                if (advancedGlobe && e.target.checked) advancedGlobe.optimizeForPerformance();
            });
            
            document.getElementById('reset-view').addEventListener('click', () => {
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 25000000),
                    orientation: {
                        heading: 0,
                        pitch: -Math.PI / 2,
                        roll: 0
                    }
                });
            });
        }
        
        // Update the main initialization to use enhanced version
        async function initializeGame() {
            try {
                console.log('üöÄ Initializing Enhanced Coalitions Globe...');
                
                // Load token from .env or use fallback
                // NOTE: Get a free token from https://cesium.com/ion/tokens
                const token = import.meta.env?.VITE_CESIUM_TOKEN || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxMTk3NGQ0YS1jOTgzLTRmMTItODE1ZC04NTU2M2ZhYmExNTAiLCJpZCI6MzIxNzgxLCJpYXQiOjE3NTI2MDQ2ODh9.hcAL5ZNXEpcJTz6OwmNWEcl2ZG1A8afrhHifi80uO4I';
                
                console.log('üîë Using Cesium token:', token.substring(0, 20) + '...');
                Cesium.Ion.defaultAccessToken = token;
                
                // Try creating viewer with terrain first, fallback to basic if it fails
                try {
                    viewer = new Cesium.Viewer('cesiumContainer', {
                        timeline: false,
                        animation: false,
                        baseLayerPicker: false,
                        fullscreenButton: true,
                        homeButton: true,
                        sceneModePicker: false,
                        geocoder: false,
                        navigationHelpButton: false,
                        vrButton: false,
                        requestRenderMode: false,
                        shadows: true,
                        terrainProvider: await Cesium.createWorldTerrainAsync({
                            requestWaterMask: true,
                            requestVertexNormals: true
                        })
                    });
                    console.log('‚úÖ Advanced terrain viewer created');
                } catch (terrainError) {
                    console.log('Using basic viewer');
                    viewer = new Cesium.Viewer('cesiumContainer', {
                        timeline: false,
                        animation: false,
                        baseLayerPicker: false,
                        fullscreenButton: true,
                        homeButton: true,
                        sceneModePicker: false,
                        geocoder: false,
                        navigationHelpButton: false,
                        vrButton: false,
                        requestRenderMode: false,
                        shadows: false
                    });
                }
                
                // Set initial view - proper Earth home view like home button
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 25000000),
                    orientation: {
                        heading: 0,
                        pitch: -Math.PI / 2,
                        roll: 0
                    }
                });
                
                // Override home button to use same view
                viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (e) {
                    e.cancel = true;
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 25000000),
                        orientation: {
                            heading: 0,
                            pitch: -Math.PI / 2,
                            roll: 0
                        },
                        duration: 2
                    });
                });
                
                // Enhanced globe settings for better Earth visibility
                viewer.scene.globe.enableLighting = false;
                viewer.scene.globe.dynamicAtmosphereLighting = false;
                viewer.scene.skyAtmosphere.brightness = 1.0;
                viewer.scene.fog.enabled = false;
                viewer.scene.globe.baseColor = Cesium.Color.BLUE;
                
                // Ensure Earth imagery loads
                viewer.scene.globe.show = true;
                viewer.scene.skyBox.show = true;
                viewer.scene.sun.show = true;
                viewer.scene.moon.show = true;
                
                // Force immediate render
                viewer.scene.requestRender();
                
                // Wait a moment then ensure Earth is visible
                setTimeout(() => {
                    if (viewer.scene.globe.show) {
                        console.log('‚úÖ Earth globe is visible');
                        showNotification('Earth Loaded', 'üåç Globe rendering successfully');
                    } else {
                        console.log('‚ùå Earth globe not visible');
                        showNotification('Loading Issue', '‚ö†Ô∏è Earth not visible - check token');
                    }
                    
                    // Hide loading screen
                    const loadingScreen = document.querySelector('.loading-screen');
                    if (loadingScreen) {
                        loadingScreen.style.opacity = '0';
                        setTimeout(() => loadingScreen.remove(), 1000);
                    }
                }, 2000);
                
                // Initialize trailer mode if requested
                if (isTrailerMode) {
                    setTimeout(() => {
                        if (cinematicTrailer) {
                            cinematicTrailer.start();
                        } else {
                            startTrailerSequence();
                        }
                    }, 3000);
                } else {
                    // Initialize enhanced globe features
                    setTimeout(() => initializeEnhancedGame(), 2000);
                }
                
                console.log('üéÆ Game initialized successfully');
                
            } catch (error) {
                console.error('‚ùå Game initialization failed:', error);
                
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Failed to load. Please refresh the page.';
                    loadingText.style.color = '#ff4444';
                }
            }
        }
        
        // EPIC CINEMATIC TRAILER - Full Production Version
        class CinematicTrailer {
            constructor(viewer) {
                this.viewer = viewer;
                this.audioContext = null;
                this.sounds = {};
                this.models = {};
                this.particles = {};
                this.activeAnimations = [];
                this.isPlaying = false;
            }
            
            // Initialize audio system
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Load and setup sounds
                    const soundUrls = {
                        bgMusic: 'https://www.soundjay.com/misc/sounds-misc-29.mp3', // Epic orchestral
                        explosion: 'https://www.soundjay.com/misc/explosion-01.mp3',
                        missile: 'https://www.soundjay.com/misc/whoosh-10.mp3',
                        alert: 'https://www.soundjay.com/misc/bell-ringing-05.mp3',
                        jet: 'https://www.soundjay.com/misc/jet-fly-by-02.mp3'
                    };
                    
                    // Create audio elements with fallback
                    for (let [name, url] of Object.entries(soundUrls)) {
                        const audio = new Audio();
                        audio.crossOrigin = 'anonymous';
                        audio.preload = 'auto';
                        audio.volume = name === 'bgMusic' ? 0.3 : 0.7;
                        if (name === 'bgMusic') audio.loop = true;
                        
                        // Fallback to Web Audio API tones if URLs fail
                        audio.onerror = () => {
                            console.log(`Creating synthetic ${name} sound`);
                            this.sounds[name] = this.createSyntheticSound(name);
                        };
                        
                        audio.oncanplaythrough = () => {
                            this.sounds[name] = audio;
                        };
                        
                        audio.src = url;
                    }
                    
                    console.log('üîä Audio system initialized');
                } catch (error) {
                    console.log('Using synthetic audio fallback');
                    this.createAllSyntheticSounds();
                }
            }
            
            // Create synthetic sounds using Web Audio API
            createSyntheticSound(type) {
                return {
                    play: () => {
                        if (!this.audioContext) return;
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        switch(type) {
                            case 'explosion':
                                oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.5);
                                gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 0.5);
                                break;
                            case 'missile':
                                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                                oscillator.frequency.linearRampToValueAtTime(400, this.audioContext.currentTime + 1);
                                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                                gainNode.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 1);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 1);
                                break;
                            case 'alert':
                                oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 0.2);
                                break;
                            case 'jet':
                                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                                oscillator.frequency.linearRampToValueAtTime(600, this.audioContext.currentTime + 2);
                                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                                gainNode.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 2);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 2);
                                break;
                        }
                    }
                };
            }
            
            createAllSyntheticSounds() {
                const soundTypes = ['bgMusic', 'explosion', 'missile', 'alert', 'jet'];
                soundTypes.forEach(type => {
                    this.sounds[type] = this.createSyntheticSound(type);
                });
            }
            
            // Play sound with error handling
            playSound(name) {
                try {
                    if (this.sounds[name] && typeof this.sounds[name].play === 'function') {
                        this.sounds[name].play();
                    }
                } catch (error) {
                    console.log(`Sound ${name} failed, using fallback`);
                }
            }
            
            // Create 3D models
            async create3DModel(type, position, options = {}) {
                const modelUrls = {
                    f35: 'https://sandcastle.cesium.com/SampleData/models/CesiumAir/Cesium_Air.gltf',
                    missile: 'https://sandcastle.cesium.com/SampleData/models/CesiumDrone/CesiumDrone.gltf',
                    ship: 'https://sandcastle.cesium.com/SampleData/models/CesiumMilkTruck/CesiumMilkTruck.gltf'
                };
                
                const entity = this.viewer.entities.add({
                    position: position,
                    orientation: Cesium.Transforms.headingPitchRollQuaternion(
                        position,
                        new Cesium.HeadingPitchRoll(0, 0, 0)
                    ),
                    model: {
                        uri: modelUrls[type] || modelUrls.f35,
                        minimumPixelSize: options.size || 64,
                        maximumScale: options.scale || 10000,
                        scale: options.modelScale || 1.0,
                        color: options.color || Cesium.Color.WHITE,
                        colorBlendMode: Cesium.ColorBlendMode.MIX,
                        colorBlendAmount: options.colorBlend || 0.0
                    }
                });
                
                return entity;
            }
            
            // Create explosion effect with particles
            createExplosion(position, intensity = 1.0) {
                this.playSound('explosion');
                
                // Main explosion sphere
                const explosion = this.viewer.entities.add({
                    position: position,
                    ellipse: {
                        semiMinorAxis: 50000 * intensity,
                        semiMajorAxis: 50000 * intensity,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const alpha = Math.max(0, 1 - (time % 2) / 2);
                                return Cesium.Color.ORANGE.withAlpha(alpha);
                            }, false)
                        ),
                        outline: true,
                        outlineColor: Cesium.Color.RED
                    }
                });
                
                // Particle system simulation with multiple entities
                for (let i = 0; i < 8; i++) {
                    const offset = Math.random() * 100000;
                    const angle = (i / 8) * Math.PI * 2;
                    const particlePos = Cesium.Cartesian3.fromDegrees(
                        Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(position).longitude) + Math.cos(angle) * 0.01,
                        Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(position).latitude) + Math.sin(angle) * 0.01,
                        offset
                    );
                    
                    const particle = this.viewer.entities.add({
                        position: particlePos,
                        ellipse: {
                            semiMinorAxis: 10000,
                            semiMajorAxis: 10000,
                            material: Cesium.Color.YELLOW.withAlpha(0.8)
                        }
                    });
                    
                    // Animate particle
                    setTimeout(() => {
                        this.viewer.entities.remove(particle);
                    }, 2000);
                }
                
                // Remove main explosion after animation
                setTimeout(() => {
                    this.viewer.entities.remove(explosion);
                }, 3000);
                
                // Screen shake effect
                this.screenShake();
                
                return explosion;
            }
            
            // Screen shake effect
            screenShake() {
                const originalTransform = document.body.style.transform;
                let shakeCount = 0;
                const shakeInterval = setInterval(() => {
                    const x = (Math.random() - 0.5) * 10;
                    const y = (Math.random() - 0.5) * 10;
                    document.body.style.transform = `translate(${x}px, ${y}px)`;
                    shakeCount++;
                    
                    if (shakeCount > 10) {
                        clearInterval(shakeInterval);
                        document.body.style.transform = originalTransform;
                    }
                }, 50);
            }
            
            // Animate object along path
            animateObjectPath(entity, startPos, endPos, duration, onComplete) {
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / (duration * 1000), 1);
                    
                    // Smooth easing
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    const currentPos = Cesium.Cartesian3.lerp(startPos, endPos, eased, new Cesium.Cartesian3());
                    entity.position = currentPos;
                    
                    // Add trail effect
                    if (progress < 1) {
                        // Create trail particle
                        const trail = this.viewer.entities.add({
                            position: currentPos,
                            point: {
                                pixelSize: 5,
                                color: Cesium.Color.CYAN.withAlpha(0.6),
                                scaleByDistance: new Cesium.NearFarScalar(1000, 1.0, 100000, 0.0)
                            }
                        });
                        
                        setTimeout(() => this.viewer.entities.remove(trail), 1000);
                        
                        requestAnimationFrame(animate);
                    } else {
                        if (onComplete) onComplete();
                    }
                };
                
                animate();
            }
            
            // Smooth camera transition
            smoothCameraMove(destination, duration, onComplete) {
                this.viewer.camera.flyTo({
                    destination: destination,
                    duration: duration,
                    complete: onComplete,
                    easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT
                });
            }
            
            // Create UI overlay with enhanced effects
            createTrailerUI() {
                const ui = document.createElement('div');
                ui.id = 'cinematic-ui';
                ui.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    pointer-events: none; z-index: 10000; font-family: 'SF Pro Text', sans-serif;
                    background: linear-gradient(45deg, rgba(0,0,0,0.1), rgba(0,0,0,0.3));
                `;
                document.body.appendChild(ui);
                
                // Enhanced voiceover with glow effect
                const voiceover = document.createElement('div');
                voiceover.id = 'voiceover';
                voiceover.style.cssText = `
                    position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
                    background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
                    color: white; padding: 25px 50px; border-radius: 15px;
                    font-size: 28px; text-align: center; font-weight: 600;
                    opacity: 0; transition: all 1s ease;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.1);
                    text-shadow: 0 0 20px rgba(255,255,255,0.5);
                    border: 1px solid rgba(255,255,255,0.2);
                `;
                ui.appendChild(voiceover);
                
                // Enhanced alert system
                const alerts = document.createElement('div');
                alerts.id = 'alert-system';
                alerts.style.cssText = `
                    position: absolute; top: 30px; right: 30px; width: 350px;
                `;
                ui.appendChild(alerts);
                
                // Resource display with animations
                const resources = document.createElement('div');
                resources.id = 'resources';
                resources.style.cssText = `
                    position: absolute; top: 30px; left: 30px;
                    background: rgba(0,0,0,0.8); color: white; padding: 20px;
                    border-radius: 10px; font-family: 'Courier New', monospace;
                    border: 1px solid #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.3);
                `;
                ui.appendChild(resources);
                
                return { ui, voiceover, alerts, resources };
            }
            
            // Show enhanced voiceover
            showVoiceover(text, duration = 4000) {
                const voiceover = document.getElementById('voiceover');
                if (voiceover) {
                    voiceover.textContent = text;
                    voiceover.style.opacity = '1';
                    voiceover.style.transform = 'translateX(-50%) scale(1.05)';
                    
                    setTimeout(() => {
                        voiceover.style.opacity = '0';
                        voiceover.style.transform = 'translateX(-50%) scale(0.95)';
                    }, duration);
                }
            }
            
            // Enhanced alert with sound and animation
            showAlert(text, type = 'danger') {
                // Limit alerts - only show the most critical ones
                const alertSystem = document.getElementById('alert-system');
                if (!alertSystem) return;
                
                // Remove "GLOBAL ALERT:" prefix for cleaner look
                const alert = document.createElement('div');
                alert.style.cssText = `
                    background: ${type === 'danger' ? 'linear-gradient(135deg, #ff4444, #cc0000)' : 'linear-gradient(135deg, #00ff88, #00cc66)'};
                    color: white; padding: 12px 20px; margin-bottom: 8px; border-radius: 8px;
                    transform: translateX(100%); transition: all 0.8s ease;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
                    border-left: 4px solid ${type === 'danger' ? '#ffffff' : '#000000'};
                    font-size: 14px; font-weight: 500;
                `;
                
                alert.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 8px; height: 8px; background: white; border-radius: 50%; animation: pulse 2s infinite;"></div>
                        ${text}
                    </div>
                `;
                
                alerts.appendChild(alert);
                
                // Animate in
                setTimeout(() => alert.style.transform = 'translateX(0)', 100);
                
                // Remove after delay - shorter duration
                setTimeout(() => {
                    alert.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (alerts.contains(alert)) {
                            alerts.removeChild(alert);
                        }
                    }, 800);
                }, 2500); // Reduced from 4000ms
            }
            
            // Show dramatic text overlay instead of alerts
            showDramaticText(text, duration = 3000, size = 'large') {
                const dramaticText = document.createElement('div');
                dramaticText.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
                    background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.8));
                    color: #ff4444; padding: ${size === 'large' ? '30px 60px' : '20px 40px'};
                    border-radius: 15px; text-align: center; z-index: 15000;
                    font-size: ${size === 'large' ? '32px' : '24px'}; font-weight: bold;
                    border: 2px solid #ff4444; box-shadow: 0 0 50px rgba(255,68,68,0.5);
                    text-shadow: 0 0 10px rgba(255,68,68,0.8);
                    transition: all 1s ease; pointer-events: none;
                `;
                dramaticText.textContent = text;
                
                document.body.appendChild(dramaticText);
                
                // Animate in
                setTimeout(() => dramaticText.style.transform = 'translate(-50%, -50%) scale(1)', 100);
                
                // Animate out
                setTimeout(() => {
                    dramaticText.style.transform = 'translate(-50%, -50%) scale(0)';
                    setTimeout(() => {
                        if (document.body.contains(dramaticText)) {
                            document.body.removeChild(dramaticText);
                        }
                    }, 1000);
                }, duration);
            }
            
            // Show location title instead of alert
            showLocationTitle(location, subtitle = '') {
                const locationTitle = document.createElement('div');
                locationTitle.style.cssText = `
                    position: fixed; bottom: 200px; left: 50px;
                    background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(30,30,30,0.8));
                    color: white; padding: 20px 30px; border-radius: 10px;
                    border-left: 4px solid #00ff88; z-index: 12000;
                    opacity: 0; transition: all 1s ease; pointer-events: none;
                `;
                locationTitle.innerHTML = `
                    <div style="font-size: 24px; font-weight: bold; margin-bottom: 5px;">${location}</div>
                    ${subtitle ? `<div style="font-size: 16px; opacity: 0.8;">${subtitle}</div>` : ''}
                `;
                
                document.body.appendChild(locationTitle);
                
                // Animate in
                setTimeout(() => locationTitle.style.opacity = '1', 100);
                
                // Remove after 4 seconds
                setTimeout(() => {
                    locationTitle.style.opacity = '0';
                    setTimeout(() => {
                        if (document.body.contains(locationTitle)) {
                            document.body.removeChild(locationTitle);
                        }
                    }, 1000);
                }, 4000);
            }
            
            // HYPER-REALISTIC GEOPOLITICAL SCENARIO
            // "The 72-Hour Crisis: When the World's Chips Stop"
            async start() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                
                console.log('üé¨ STARTING HYPER-REALISTIC SCENARIO: "The 72-Hour Crisis"');
                
                // Initialize audio and UI
                await this.initAudio();
                const uiElements = this.createTrailerUI();
                
                // Hide game UI
                document.querySelectorAll('.return-button, .satellite-button, .cesium-toolbar').forEach(el => {
                    if (el) el.style.display = 'none';
                });
                
                // Start background music
                setTimeout(() => this.playSound('bgMusic'), 1000);
                
                // HOUR 0: The Semiconductor Trigger
                this.hourZero();
            }
            
            // Fix coordinate validation issues
            validateCoordinates(lon, lat) {
                // Ensure longitude is within -180 to 180 degrees
                lon = ((lon + 180) % 360 + 360) % 360 - 180;
                // Ensure latitude is within -90 to 90 degrees
                lat = Math.max(-90, Math.min(90, lat));
                return { lon, lat };
            }
            
            // HOUR 0: The Semiconductor Crisis Begins (IMPROVED)
            hourZero() {
                console.log('üé¨ ACT I: THE SPARK');
                this.showVoiceover("HOUR 0: Taiwan Strait - A single miscalculation...", 6000);
                
                // Start with peaceful TSMC facilities in Taiwan
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(120.9605, 24.7736, 500000), // Taiwan
                    4,
                    () => {
                        // Show location title instead of alert
                        this.showLocationTitle("Taiwan Semiconductor", "TSMC Fabrication Facilities");
                        
                        // Show TSMC facilities
                        this.createTSMCFacilities();
                        
                        setTimeout(() => {
                            // Only one critical alert
                            this.showAlert("Naval exercises escalate - TSMC production halted", "danger");
                            
                            // Dramatic text overlay
                            this.showDramaticText("90% OF WORLD'S ADVANCED CHIPS", 4000, 'large');
                            
                            // Create naval blockade visualization
                            this.createNavalBlockade();
                            
                            // Show immediate market reaction with dramatic text
                            setTimeout(() => {
                                this.showDramaticText("MARKETS IN FREEFALL", 3000);
                                
                                // Move to global impact
                                setTimeout(() => this.hourSix(), 4000);
                            }, 3000);
                        }, 4000);
                    }
                );
            }
            
            // Create TSMC facilities (FIXED)
            createTSMCFacilities() {
                const tsmcLocations = [
                    { lon: 120.9605, lat: 24.7736, name: "Fab 18 (3nm)" },
                    { lon: 120.3397, lat: 24.1469, name: "Fab 15 (7nm)" },
                    { lon: 120.9777, lat: 24.8138, name: "Fab 12 (28nm)" }
                ];
                
                tsmcLocations.forEach((fab, i) => {
                    // Validate coordinates
                    const coords = this.validateCoordinates(fab.lon, fab.lat);
                    
                    // Create glowing fab facility
                    const facility = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 100),
                        box: {
                            dimensions: new Cesium.Cartesian3(500, 300, 50),
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.7 + Math.sin(time * 2 + i) * 0.3;
                                    return Cesium.Color.CYAN.withAlpha(alpha);
                                }, false)
                            ),
                            outline: true,
                            outlineColor: Cesium.Color.WHITE
                        },
                        label: {
                            text: fab.name,
                            font: '12pt monospace',
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -50)
                        }
                    });
                });
            }
            
            // Create naval blockade visualization (FIXED)
            createNavalBlockade() {
                // Chinese naval positions - validated coordinates
                const navalPositions = [
                    { lon: 119.5, lat: 25.2 }, { lon: 120.2, lat: 25.8 },
                    { lon: 121.8, lat: 24.5 }, { lon: 121.2, lat: 23.8 },
                    { lon: 119.8, lat: 23.5 }, { lon: 118.9, lat: 24.1 }
                ];
                
                navalPositions.forEach((pos, i) => {
                    // Validate coordinates
                    const coords = this.validateCoordinates(pos.lon, pos.lat);
                    
                    // Create naval vessels
                    const vessel = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                        ellipse: {
                            semiMinorAxis: 2000,
                            semiMajorAxis: 4000,
                            material: Cesium.Color.RED.withAlpha(0.8),
                            outline: true,
                            outlineColor: Cesium.Color.DARKRED
                        }
                    });
                    
                    // Add radar coverage circles
                    const radarCoverage = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                        ellipse: {
                            semiMinorAxis: 50000,
                            semiMajorAxis: 50000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.2 + Math.sin(time * 3 + i) * 0.1;
                                    return Cesium.Color.RED.withAlpha(alpha);
                                }, false)
                            )
                        }
                    });
                });
                
                // Shipping lane blockade - fixed coordinates
                const blockadeCoords = [
                    118.0, 22.0, 122.0, 26.0, 124.0, 24.0, 120.0, 20.0, 118.0, 22.0
                ];
                
                // Validate all coordinates
                const validatedCoords = [];
                for (let i = 0; i < blockadeCoords.length; i += 2) {
                    const coords = this.validateCoordinates(blockadeCoords[i], blockadeCoords[i + 1]);
                    validatedCoords.push(coords.lon, coords.lat);
                }
                
                const blockedShipping = this.viewer.entities.add({
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArray(validatedCoords),
                        width: 10,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.3,
                            color: Cesium.Color.RED
                        }),
                        clampToGround: false,
                        height: 1000
                    }
                });
            }
            
            // HOUR 6: Global Supply Chain Collapse (IMPROVED)
            hourSix() {
                console.log('üé¨ ACT II: THE RIPPLE');
                this.showVoiceover("HOUR 6: 90% of advanced chips come from here. The world stops.", 6000);
                
                // Pull back to show global shipping routes
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(140, 20, 8000000),
                    5,
                    () => {
                        // Show disrupted shipping routes
                        this.createDisruptedShipping();
                        
                        // Factory shutdowns cascade - use dramatic text instead of alerts
                        const factoryShutdowns = [
                            { pos: [139.6917, 35.6895], name: "TOKYO", subtitle: "Toyota production halted", country: "Japan" },
                            { pos: [-83.0458, 42.3314], name: "DETROIT", subtitle: "Ford assembly lines suspended", country: "USA" },
                            { pos: [8.6821, 50.1109], name: "GERMANY", subtitle: "Volkswagen plants offline", country: "Germany" },
                            { pos: [121.4737, 31.2304], name: "SHANGHAI", subtitle: "Tesla factory shutdown", country: "China" }
                        ];
                        
                        factoryShutdowns.forEach((shutdown, i) => {
                            setTimeout(() => {
                                // Show location title instead of alert
                                this.showLocationTitle(shutdown.name, shutdown.subtitle);
                                
                                // Create factory shutdown visualization
                                const coords = this.validateCoordinates(shutdown.pos[0], shutdown.pos[1]);
                                const factory = this.createSafeEntity({
                                    position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                                    ellipse: {
                                        semiMinorAxis: 30000,
                                        semiMajorAxis: 30000,
                                        material: Cesium.Color.ORANGE.withAlpha(0.7),
                                        outline: true,
                                        outlineColor: Cesium.Color.RED
                                    }
                                });
                                
                                // Add smoke effect
                                this.createSmokeEffect([coords.lon, coords.lat]);
                            }, i * 2000);
                        });
                        
                        // One dramatic summary text
                        setTimeout(() => {
                            this.showDramaticText("GLOBAL MANUFACTURING COLLAPSE", 4000, 'large');
                        }, 6000);
                        
                        setTimeout(() => this.hourTwelve(), 10000);
                    }
                );
            }
            
            // Create disrupted shipping visualization (FIXED)
            createDisruptedShipping() {
                // Major shipping routes now blocked or delayed
                const shippingRoutes = [
                    { 
                        route: [121, 25, 140, 35, 179, 40, -150, 45, -120, 35], // Fixed to avoid 180¬∞ crossing
                        status: "blocked",
                        name: "Trans-Pacific Route"
                    },
                    { 
                        route: [121, 25, 103, 1, 80, 10, 60, 25, 45, 30], 
                        status: "delayed",
                        name: "Asia-Middle East Route"
                    },
                    { 
                        route: [121, 25, 100, -10, 80, -20, 20, -35, 0, 0], 
                        status: "rerouting",
                        name: "Asia-Europe Route"
                    }
                ];
                
                shippingRoutes.forEach(route => {
                    // Validate all coordinates in route
                    const validatedRoute = [];
                    for (let i = 0; i < route.route.length; i += 2) {
                        const coords = this.validateCoordinates(route.route[i], route.route[i + 1]);
                        validatedRoute.push(coords.lon, coords.lat);
                    }
                    
                    const color = route.status === "blocked" ? Cesium.Color.RED :
                                 route.status === "delayed" ? Cesium.Color.ORANGE :
                                 Cesium.Color.YELLOW;
                    
                    const shippingLine = this.viewer.entities.add({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArray(validatedRoute),
                            width: 6,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.2,
                                color: color.withAlpha(0.8)
                            }),
                            clampToGround: false,
                            height: 10000
                        }
                    });
                    
                    // Add animated cargo ships stuck in routes
                    if (route.status === "blocked") {
                        this.createStuckCargoShips(validatedRoute);
                    }
                });
            }
            
            createStuckCargoShips(positions) {
                // Create cargo ships stuck at sea with safe coordinates
                for (let i = 0; i < positions.length - 2; i += 4) {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(positions[i], positions[i + 1]);
                        
                        const ship = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                            rectangle: {
                                coordinates: this.createSafeRectangle(
                                    coords.lon - 0.05, coords.lat - 0.02,
                                    coords.lon + 0.05, coords.lat + 0.02
                                ),
                                material: Cesium.Color.GRAY,
                                height: 0,
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create cargo ship at position ${i}:`, error);
                    }
                }
            }
            
            createSmokeEffect(position) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    // Industrial smoke/shutdown effect
                    const smokeSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                        image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                        startColor: Cesium.Color.GRAY.withAlpha(0.8),
                        endColor: Cesium.Color.BLACK.withAlpha(0.1),
                        startScale: 20.0,
                        endScale: 50.0,
                        minimumParticleLife: 3.0,
                        maximumParticleLife: 6.0,
                        minimumSpeed: 2.0,
                        maximumSpeed: 8.0,
                        imageSize: new Cesium.Cartesian2(25, 25),
                        emissionRate: 30.0,
                        lifetime: 8.0,
                        emitter: new Cesium.CircleEmitter(5000.0),
                        modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
                            Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 500)
                        )
                    }));
                    
                    // Remove after 8 seconds
                    setTimeout(() => {
                        try {
                            this.viewer.scene.primitives.remove(smokeSystem);
                        } catch (e) {
                            console.warn('Failed to remove smoke system:', e);
                        }
                    }, 8000);
                } catch (error) {
                    console.warn('Failed to create smoke effect:', error);
                }
            }
            
            createFinancialCrisis(position, type) {
                // Validate coordinates
                const coords = this.validateCoordinates(position[0], position[1]);
                
                const colors = {
                    market: Cesium.Color.RED,
                    currency: Cesium.Color.ORANGE,
                    banking: Cesium.Color.PURPLE,
                    central_bank: Cesium.Color.BLUE,
                    controls: Cesium.Color.YELLOW
                };
                
                // Financial crisis visualization
                const crisis = this.viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                    ellipse: {
                        semiMinorAxis: 100000,
                        semiMajorAxis: 100000,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const alpha = 0.4 + Math.sin(time * 4) * 0.3;
                                return colors[type].withAlpha(alpha);
                            }, false)
                        ),
                        outline: true,
                        outlineColor: colors[type]
                    }
                });
                
                // Add pulsing effect
                this.createPulsingEffect([coords.lon, coords.lat], colors[type]);
            }
            
            createDataStreamAttack(targetPos) {
                // Validate target coordinates
                const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                
                // Create attack vector lines from various origins
                const attackOrigins = [
                    [116.4074, 39.9042], // Beijing
                    [37.6176, 55.7558],  // Moscow
                    [55.2708, 25.2048]   // Dubai (proxy)
                ];
                
                attackOrigins.forEach(origin => {
                    // Validate origin coordinates
                    const originCoords = this.validateCoordinates(origin[0], origin[1]);
                    
                    const attackVector = this.viewer.entities.add({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                originCoords.lon, originCoords.lat, 20000,
                                targetCoords.lon, targetCoords.lat, 5000
                            ]),
                            width: 4,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.3,
                                color: Cesium.Color.MAGENTA.withAlpha(0.8)
                            })
                        }
                    });
                });
            }
            
            createRefugeeCamp(position) {
                // Validate coordinates and add small offset for camp location
                const coords = this.validateCoordinates(position[0] + 0.1, position[1] + 0.1);
                
                // Refugee camp visualization
                const camp = this.viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                    ellipse: {
                        semiMinorAxis: 15000,
                        semiMajorAxis: 25000,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const alpha = 0.5 + Math.sin(time) * 0.2;
                                return Cesium.Color.BROWN.withAlpha(alpha);
                            }, false)
                        ),
                        outline: true,
                        outlineColor: Cesium.Color.WHITE
                    }
                });
            }
            
            createASATAttack(targetPos) {
                // Anti-satellite weapon launch
                const launchSite = [116.4074, 39.9042, 0]; // China
                
                // Validate launch site coordinates
                const launchCoords = this.validateCoordinates(launchSite[0], launchSite[1]);
                
                // Validate target coordinates (space coordinates don't need validation but we'll be safe)
                const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                
                // Missile trajectory to satellite
                const asatMissile = this.viewer.entities.add({
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                            launchCoords.lon, launchCoords.lat, launchSite[2],
                            targetCoords.lon, targetCoords.lat, targetPos[2]
                        ]),
                        width: 5,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.4,
                            color: Cesium.Color.RED.withAlpha(0.9)
                        })
                    }
                });
                
                // Satellite explosion
                setTimeout(() => {
                    this.createExplosion(
                        Cesium.Cartesian3.fromDegrees(targetCoords.lon, targetCoords.lat, targetPos[2]),
                        0.8
                    );
                }, 2000);
            }
            
            // Add coordinate validation to all other functions that use coordinates
            createPulsingEffect(position, color) {
                // Validate coordinates
                const coords = this.validateCoordinates(position[0], position[1]);
                
                const pulseEffect = this.viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 2000),
                    ellipse: {
                        semiMinorAxis: 50000,
                        semiMajorAxis: 50000,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const scale = 1 + Math.sin(time * 6) * 0.5;
                                const alpha = 0.3 + Math.sin(time * 6) * 0.2;
                                return color.withAlpha(alpha);
                            }, false)
                        )
                    }
                });
                
                // Remove after 5 seconds
                setTimeout(() => {
                    this.viewer.entities.remove(pulseEffect);
                }, 5000);
            }
            
            // HOUR 12: Economic Warfare & Cyber Attacks (IMPROVED)
            hourTwelve() {
                console.log('üé¨ ACT III: THE CHOICE');
                this.showVoiceover("HOUR 12: When economics becomes warfare...", 6000);
                
                // Show global financial centers
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(-74.006, 40.7128, 2000000), // NYC
                    4,
                    () => {
                        // Financial warfare cascade - reduce alerts, use location titles
                        const financialAttacks = [
                            { pos: [-74.006, 40.7128], location: "NEW YORK", subtitle: "NYSE circuit breakers triggered", type: "market" },
                            { pos: [-0.1276, 51.5074], location: "LONDON", subtitle: "Pound crashes to historic low", type: "currency" },
                            { pos: [139.6917, 35.6895], location: "TOKYO", subtitle: "Banking system under stress", type: "banking" },
                            { pos: [8.6821, 50.1109], location: "FRANKFURT", subtitle: "ECB emergency protocols", type: "central_bank" }
                        ];
                        
                        financialAttacks.forEach((attack, i) => {
                            setTimeout(() => {
                                // Use location titles instead of alerts
                                this.showLocationTitle(attack.location, attack.subtitle);
                                this.createFinancialCrisis(attack.pos, attack.type);
                                
                                // Cyber attack visualization - only for one location
                                if (i === 2) { // During Tokyo crisis
                                    setTimeout(() => {
                                        this.showDramaticText("CYBER WARFARE INITIATED", 4000);
                                        this.createCyberAttackWave();
                                    }, 1000);
                                }
                            }, i * 2500);
                        });
                        
                        setTimeout(() => this.hourTwentyFour(), 12000);
                    }
                );
            }
            
            createCyberAttackWave() {
                // Cyber attack spreading across continents
                const cyberTargets = [
                    { pos: [-77.0369, 38.9072], name: "Pentagon systems compromised" },
                    { pos: [-0.1276, 51.5074], name: "London: Power grid fluctuations" },
                    { pos: [2.3522, 48.8566], name: "Paris: Metro system disrupted" },
                    { pos: [13.4050, 52.5200], name: "Berlin: Government networks down" },
                    { pos: [37.6176, 55.7558], name: "Moscow: Counter-cyber operations" }
                ];
                
                cyberTargets.forEach((target, i) => {
                    setTimeout(() => {
                        this.showAlert(`CYBER: ${target.name}`, "danger");
                        
                        // Create cyber attack visualization
                        const cyberEffect = this.viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(target.pos[0], target.pos[1], 5000),
                            ellipse: {
                                semiMinorAxis: 50000,
                                semiMajorAxis: 50000,
                                material: new Cesium.ColorMaterialProperty(
                                    new Cesium.CallbackProperty(() => {
                                        const time = Date.now() / 1000;
                                        const alpha = 0.6 + Math.sin(time * 8) * 0.4;
                                        return Cesium.Color.MAGENTA.withAlpha(alpha);
                                    }, false)
                                )
                            }
                        });
                        
                        // Create data stream lines showing attack vectors
                        this.createDataStreamAttack(target.pos);
                    }, i * 1000);
                });
            }
            
            // HOUR 24: Alliance Fractures & Refugee Crisis (IMPROVED)
            hourTwentyFour() {
                console.log('üé¨ ACT IV: THE STORM');
                this.showVoiceover("HOUR 24: When allies become adversaries...", 6000);
                
                // Show alliance breakdown
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(10, 50, 6000000), // Europe
                    5,
                    () => {
                        // Dramatic text instead of multiple alerts
                        this.showDramaticText("ALLIANCES FRACTURING", 4000, 'large');
                        
                        // Alliance fractures - minimal alerts, more visual
                        this.showAllianceFractures();
                        
                        // Refugee flows
                        setTimeout(() => {
                            this.showDramaticText("MASS DISPLACEMENT", 4000);
                            this.createRefugeeCrisis();
                        }, 3000);
                        
                        // Resource wars
                        setTimeout(() => {
                            this.showDramaticText("RESOURCE WARS", 4000);
                            this.createResourceWars();
                        }, 6000);
                        
                        setTimeout(() => this.hourFortyEight(), 12000);
                    }
                );
            }
            
            showAllianceFractures() {
                // Show only 2-3 key fractures, not all of them
                const keyFractures = [
                    { event: "NATO Article 5 suspended", pos: [13.4050, 52.5200], location: "BERLIN" },
                    { event: "Bosphorus Strait closed to US", pos: [28.9784, 41.0082], location: "ISTANBUL" },
                    { event: "Yuan accepted for oil trades", pos: [46.6753, 24.7136], location: "RIYADH" }
                ];
                
                keyFractures.forEach((crisis, i) => {
                    setTimeout(() => {
                        // Use location titles instead of alerts
                        this.showLocationTitle(crisis.location, crisis.event);
                        
                        // Show alliance break visualization
                        const coords = this.validateCoordinates(crisis.pos[0], crisis.pos[1]);
                        const breakPoint = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                            ellipse: {
                                semiMinorAxis: 80000,
                                semiMajorAxis: 80000,
                                material: Cesium.Color.YELLOW.withAlpha(0.6),
                                outline: true,
                                outlineColor: Cesium.Color.ORANGE
                            }
                        });
                    }, i * 2000);
                });
            }
            
            createRefugeeCrisis() {
                // Show only the most significant refugee flow
                const majorFlow = { 
                    from: [121.5654, 25.0330], // Taiwan
                    to: [121.7740, 12.8797],   // Philippines
                    count: "2.3M refugees"
                };
                
                // Use location title instead of alert
                this.showLocationTitle("TAIWAN STRAIT", "Massive evacuation underway");
                
                // Create refugee flow visualization
                const fromCoords = this.validateCoordinates(majorFlow.from[0], majorFlow.from[1]);
                const toCoords = this.validateCoordinates(majorFlow.to[0], majorFlow.to[1]);
                
                const refugeePath = this.createSafeEntity({
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArray([
                            fromCoords.lon, fromCoords.lat,
                            toCoords.lon, toCoords.lat
                        ]),
                        width: 8,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.2,
                            color: Cesium.Color.ORANGE.withAlpha(0.7)
                        }),
                        clampToGround: false,
                        height: 5000
                    }
                });
                
                // Animated refugee camps
                this.createRefugeeCamp([toCoords.lon, toCoords.lat]);
            }
            
            createResourceWars() {
                // Critical resource conflicts
                const resourceConflicts = [
                    { pos: [-109.0428, 37.2431], resource: "Rare Earth Mines - Utah", type: "mining" },
                    { pos: [31.2357, 30.0444], resource: "Suez Canal - Blocked", type: "chokepoint" },
                    { pos: [56.2833, 25.2048], resource: "Strait of Hormuz - Mined", type: "energy" },
                    { pos: [103.8198, 1.3521], resource: "Malacca Strait - Contested", type: "shipping" }
                ];
                
                resourceConflicts.forEach((conflict, i) => {
                    setTimeout(() => {
                        this.showAlert(`Resource War: ${conflict.resource}`, "danger");
                        
                        const resourceMarker = this.viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(conflict.pos[0], conflict.pos[1], 1000),
                            ellipse: {
                                semiMinorAxis: 30000,
                                semiMajorAxis: 30000,
                                material: Cesium.Color.PURPLE.withAlpha(0.7),
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            }
                        });
                        
                        // Add conflict explosion effect
                        this.createExplosion(
                            Cesium.Cartesian3.fromDegrees(conflict.pos[0], conflict.pos[1], 0), 
                            1.2
                        );
                    }, i * 1500);
                });
            }
            
            // HOUR 48: Climate Multiplier & Space War
            hourFortyEight() {
                console.log('üé¨ HOUR 48: Climate Multiplier & Space War');
                this.showVoiceover("HOUR 48: When Earth's systems fail, the war moves to space...", 7000);
                
                // Pull back to show climate effects
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(0, 0, 15000000),
                    6,
                    () => {
                        // Climate warfare
                        this.createClimateWarfare();
                        
                        // Space militarization
                        setTimeout(() => {
                            this.createSpaceWarfare();
                        }, 4000);
                        
                        // Final cascade
                        setTimeout(() => this.hourSeventyTwo(), 10000);
                    }
                );
            }
            
            createClimateWarfare() {
                // Climate-induced conflicts
                const climateEvents = [
                    { pos: [77.1025, 28.7041], event: "Delhi: Water riots, 50¬∞C heat", effect: "drought" },
                    { pos: [-89.4012, 13.7942], event: "Central America: Climate migration surge", effect: "migration" },
                    { pos: [2.3522, 48.8566], event: "Europe: Power grid fails in heatwave", effect: "infrastructure" },
                    { pos: [144.9631, -37.8136], event: "Australia: Bushfires threaten cities", effect: "disaster" }
                ];
                
                climateEvents.forEach((event, i) => {
                    setTimeout(() => {
                        this.showAlert(`CLIMATE: ${event.event}`, "danger");
                        
                        // Climate effect visualization
                        const climateEffect = this.viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(event.pos[0], event.pos[1], 0),
                            ellipse: {
                                semiMinorAxis: 200000,
                                semiMajorAxis: 300000,
                                material: new Cesium.ColorMaterialProperty(
                                    new Cesium.CallbackProperty(() => {
                                        const time = Date.now() / 1000;
                                        const alpha = 0.3 + Math.sin(time * 2) * 0.2;
                                        return event.effect === 'drought' ? Cesium.Color.RED.withAlpha(alpha) :
                                               event.effect === 'migration' ? Cesium.Color.ORANGE.withAlpha(alpha) :
                                               event.effect === 'infrastructure' ? Cesium.Color.PURPLE.withAlpha(alpha) :
                                               Cesium.Color.YELLOW.withAlpha(alpha);
                                    }, false)
                                )
                            }
                        });
                    }, i * 1500);
                });
            }
            
            createSpaceWarfare() {
                // Satellite warfare
                const spaceAssets = [
                    { pos: [0, 0, 35786000], name: "GPS Constellation", type: "navigation" },
                    { pos: [0, 30, 35786000], name: "Communications Sats", type: "comms" },
                    { pos: [0, -30, 35786000], name: "Spy Satellites", type: "intel" },
                    { pos: [30, 0, 35786000], name: "Weather Monitoring", type: "weather" }
                ];
                
                spaceAssets.forEach((asset, i) => {
                    setTimeout(() => {
                        this.showAlert(`SPACE: ${asset.name} under attack`, "danger");
                        
                        // Create satellite
                        const satellite = this.viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(asset.pos[0], asset.pos[1], asset.pos[2]),
                            ellipse: {
                                semiMinorAxis: 100000,
                                semiMajorAxis: 100000,
                                material: Cesium.Color.SILVER.withAlpha(0.8),
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            }
                        });
                        
                        // Anti-satellite weapon
                        setTimeout(() => {
                            this.createASATAttack(asset.pos);
                        }, 1000);
                    }, i * 2000);
                });
            }
            
            // HOUR 72: The Final Choice
            hourSeventyTwo() {
                console.log('üé¨ HOUR 72: The Final Choice');
                
                // Pull back to devastated Earth
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(0, 0, 25000000),
                    8,
                    () => {
                        setTimeout(() => {
                            this.showVoiceover("HOUR 72: 3 billion displaced. Markets collapsed. Alliances shattered.", 8000);
                            
                            // Show global devastation statistics
                            this.showGlobalStats();
                            
                            setTimeout(() => {
                                this.showVoiceover("Every decision cascades. Every alliance matters. What world will you create?", 10000);
                                
                                // Final decision interface
                                this.showFinalDecision();
                                
                                // Auto-restart after 12 seconds
                                setTimeout(() => {
                                    this.cleanup();
                                    setTimeout(() => this.start(), 3000);
                                }, 12000);
                            }, 8000);
                        }, 3000);
                    }
                );
            }
            
            showGlobalStats() {
                const stats = document.createElement('div');
                stats.style.cssText = `
                    position: fixed; top: 20%; right: 5%; width: 300px;
                    background: rgba(0,0,0,0.9); color: white; padding: 20px;
                    border-radius: 15px; font-family: 'Courier New', monospace;
                    border: 2px solid #ff4444; box-shadow: 0 0 30px rgba(255,68,68,0.5);
                    animation: pulse 2s infinite;
                `;
                
                stats.innerHTML = `
                    <h3 style="color: #ff4444; margin: 0 0 15px 0;">GLOBAL IMPACT - HOUR 72</h3>
                    <div style="margin-bottom: 8px;">üíÄ Casualties: 847,000</div>
                    <div style="margin-bottom: 8px;">üèÉ Displaced: 3.2 billion</div>
                    <div style="margin-bottom: 8px;">üìâ GDP Lost: $47 trillion</div>
                    <div style="margin-bottom: 8px;">üè≠ Factories Closed: 78%</div>
                    <div style="margin-bottom: 8px;">üõ°Ô∏è Alliances Broken: 12</div>
                    <div style="margin-bottom: 8px;">üåä Ports Blockaded: 156</div>
                    <div style="margin-bottom: 8px;">‚ö° Power Grids Down: 34%</div>
                    <div style="margin-bottom: 8px;">üõ∞Ô∏è Satellites Destroyed: 89</div>
                    <div style="color: #ff4444; font-weight: bold;">‚ö†Ô∏è CIVILIZATION: CRITICAL</div>
                `;
                
                document.body.appendChild(stats);
                
                // Remove after 10 seconds
                setTimeout(() => {
                    if (stats.parentNode) {
                        document.body.removeChild(stats);
                    }
                }, 10000);
            }
            
            showFinalDecision() {
                const finalChoice = document.createElement('div');
                finalChoice.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
                    background: linear-gradient(135deg, #000, #1a1a2e, #16213e);
                    color: white; padding: 50px; border-radius: 25px; text-align: center;
                    width: 600px; z-index: 50000; transition: transform 2s ease;
                    border: 3px solid #00ff88; box-shadow: 0 0 100px rgba(0,255,136,0.8);
                `;
                
                finalChoice.innerHTML = `
                    <h1 style="margin: 0 0 30px 0; color: #00ff88; font-size: 42px; text-shadow: 0 0 20px rgba(0,255,136,0.8);">
                        COALITIONS
                    </h1>
                    <h2 style="margin: 0 0 25px 0; color: #ff4444; font-size: 24px;">
                        The 72-Hour Crisis
                    </h2>
                    <p style="margin: 0 0 25px 0; font-size: 18px; line-height: 1.5;">
                        When semiconductors stop flowing, civilization stops working.<br/>
                        Every alliance. Every decision. Every consequence.
                    </p>
                    <p style="margin: 0 0 30px 0; font-size: 16px; color: #ccc;">
                        Experience the most realistic geopolitical strategy simulation ever created.
                    </p>
                    <div style="font-size: 18px; color: #00ff88; font-weight: bold;">
                        Coming Soon to Steam
                    </div>
                `;
                
                document.body.appendChild(finalChoice);
                
                // Animate in
                setTimeout(() => finalChoice.style.transform = 'translate(-50%, -50%) scale(1)', 500);
            }
            
            // Cleanup function
            cleanup() {
                // Stop sounds
                Object.values(this.sounds).forEach(sound => {
                    if (sound.pause) sound.pause();
                });
                
                // Remove entities
                this.viewer.entities.removeAll();
                
                // Remove UI
                const ui = document.getElementById('cinematic-ui');
                if (ui) ui.remove();
                
                // Remove any remaining popups
                document.querySelectorAll('[style*="position: fixed"]').forEach(el => {
                    if (el.textContent.includes('COALITION')) el.remove();
                });
                
                this.isPlaying = false;
            }
        }
        
        // Initialize cinematic trailer
        let cinematicTrailer = null;
        
        // Enhanced trailer start function
        function startTrailerSequence() {
            if (!cinematicTrailer) {
                cinematicTrailer = new CinematicTrailer(viewer);
            }
            cinematicTrailer.start();
        }
        
        // Notification system
        function showNotification(title, message) {
            const notification = document.getElementById('notification');
            const titleElement = document.getElementById('notificationTitle');
            const textElement = document.getElementById('notificationText');
            
            if (notification && titleElement && textElement) {
                titleElement.textContent = title;
                textElement.textContent = message;
                notification.classList.add('show');
                
            setTimeout(() => {
                    notification.classList.remove('show');
                }, 4000);
            }
        }
        
        // Satellite mode button
        document.getElementById('satelliteModeBtn').addEventListener('click', () => {
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(0, 0, 15000000),
                orientation: {
                    heading: 0,
                    pitch: -Math.PI / 2,
                    roll: 0
                },
                duration: 3
            });
            showNotification('Satellite Mode', 'üõ∞Ô∏è Overhead surveillance view');
        });
        
        // Start loading
        updateLoading();
    </script>
</body>
</html>