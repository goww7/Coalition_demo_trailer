<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coalitions MVP - Interactive Globe</title>
    
    <!-- Cesium -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            height: 100%;
            font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #cesiumContainer {
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Trailer animations */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(15, 25, 45, 0.9) 50%, rgba(0, 102, 255, 0.8) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(1.1);
        }

        .loading-title {
            font-size: clamp(3rem, 8vw, 5rem);
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #ffffff, #5AC8FA, #007AFF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .loading-subtitle {
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 2rem;
        }

        .loading-progress {
            width: 400px;
            max-width: 80vw;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #5AC8FA, #007AFF);
            width: 0%;
            transition: width 0.5s ease;
        }

        .loading-text {
            color: #ccc;
            text-align: center;
        }

        .loading-features {
            margin-top: 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            max-width: 800px;
        }

        .loading-feature {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .loading-feature-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .loading-feature-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Navigation */
        .return-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(90, 200, 250, 0.9) 0%, rgba(0, 122, 255, 1) 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 24px;
            font-weight: 600;
            text-decoration: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .return-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(90, 200, 250, 0.4);
        }

        .satellite-button {
            position: fixed;
            top: 20px;
            left: 250px;
            background: linear-gradient(135deg, rgba(255, 68, 68, 0.9) 0%, rgba(200, 0, 0, 1) 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 24px;
            font-weight: 600;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .satellite-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(255, 68, 68, 0.4);
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(90, 200, 250, 0.4);
            border-radius: 12px;
            padding: 15px 20px;
            max-width: 350px;
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.4s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification-title {
            font-weight: 600;
            color: #5AC8FA;
            margin-bottom: 5px;
        }

        .notification-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-header">
            <h1 class="loading-title">COALITIONS</h1>
            <p class="loading-subtitle">Advanced Military Simulation</p>
        </div>
        
            <div class="loading-progress">
                <div class="loading-bar" id="loadingBar"></div>
            </div>
        <p class="loading-text" id="loadingText">Initializing systems...</p>

        <div class="loading-features">
            <div class="loading-feature">
                <div class="loading-feature-icon">üéñÔ∏è</div>
                <div class="loading-feature-text">Military Simulation</div>
            </div>
            <div class="loading-feature">
                <div class="loading-feature-icon">üí•</div>
                <div class="loading-feature-text">Realtime Effects</div>
            </div>
            <div class="loading-feature">
                <div class="loading-feature-icon">üå¶Ô∏è</div>
                <div class="loading-feature-text">Weather Systems</div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <a href="index.html" class="return-button">‚Üê NASA Earth Landing</a>
    <button class="satellite-button" id="satelliteModeBtn">üõ∞Ô∏è Satellite Mode</button>

    <!-- Notification -->
    <div class="notification" id="notification">
        <div class="notification-title" id="notificationTitle"></div>
        <div class="notification-text" id="notificationText"></div>
    </div>

    <!-- Cesium Container -->
    <div id="cesiumContainer"></div>

    <!-- Clean Script -->
    <script type="module">
        // Trailer mode detection
        const isTrailerMode = new URLSearchParams(window.location.search).get('trailer') === '1';
        
        let viewer;
        let isLoading = true;
        
        // Loading steps
        const loadingSteps = [
            { text: 'Loading Cesium 3D Engine...', duration: 800 },
            { text: 'Initializing NASA Earth Imagery...', duration: 1000 },
            { text: 'Loading Military Assets...', duration: 800 },
            { text: 'Establishing Connections...', duration: 600 },
            { text: 'Final System Check...', duration: 400 }
        ];

        let currentStep = 0;
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');

        function updateLoading() {
            if (currentStep < loadingSteps.length) {
                const step = loadingSteps[currentStep];
                const progress = ((currentStep + 1) / loadingSteps.length) * 100;
                
                loadingBar.style.width = progress + '%';
                loadingText.textContent = step.text;
                
                setTimeout(() => {
                    currentStep++;
                    updateLoading();
                }, step.duration);
            } else {
                setTimeout(initializeEnhancedGame, 300);
            }
        }
        
        // ADVANCED GLOBE ENRICHMENT SYSTEM
        class AdvancedGlobeEnrichment {
            constructor(viewer) {
                this.viewer = viewer;
                this.weatherSystem = null;
                this.particleSystem = null;
                this.lightingSystem = null;
                this.oceanSystem = null;
                this.isInitialized = false;
            }
            
            async initialize() {
                if (this.isInitialized) return;
                
                console.log('üåç Initializing Advanced Globe Enrichment...');
                
                // Initialize all advanced systems
                await this.initializePhotorealisticTiles();
                await this.initializeAdvancedTerrain();
                await this.initializeWeatherSystem();
                await this.initializeParticleSystem();
                await this.initializeDynamicLighting();
                await this.initializeOceanEffects();
                await this.initializePostProcessing();
                
                this.isInitialized = true;
                console.log('‚úÖ Advanced Globe Enrichment Complete!');
                
                // Show notification
                showNotification('Globe Enhanced', 'üåç Advanced visual systems activated');
            }
            
            // Google Photorealistic 3D Tiles for major cities
            async initializePhotorealisticTiles() {
                try {
                    console.log('üèôÔ∏è Loading Photorealistic 3D Tiles...');
                    
                    // Major cities with Photorealistic 3D Tiles
                    const photorealisticCities = [
                        { name: 'New York', lon: -74.006, lat: 40.7128, enabled: true },
                        { name: 'London', lon: -0.1276, lat: 51.5074, enabled: true },
                        { name: 'Paris', lon: 2.3522, lat: 48.8566, enabled: true },
                        { name: 'Tokyo', lon: 139.6917, lat: 35.6895, enabled: true },
                        { name: 'Sydney', lon: 151.2093, lat: -33.8688, enabled: true },
                        { name: 'San Francisco', lon: -122.4194, lat: 37.7749, enabled: true },
                        { name: 'Berlin', lon: 13.4050, lat: 52.5200, enabled: true },
                        { name: 'Dubai', lon: 55.2708, lat: 25.2048, enabled: true }
                    ];
                    
                    // Add Google Photorealistic 3D Tiles
                    const googleTileset = await Cesium.Cesium3DTileset.fromUrl(
                        'https://tile.googleapis.com/v1/3dtiles/root.json?key=' + this.viewer.cesiumWidget.cesiumIon.defaultAccessToken
                    );
                    
                    this.viewer.scene.primitives.add(googleTileset);
                    
                    // Style the tileset for better integration
                    googleTileset.style = new Cesium.Cesium3DTileStyle({
                        color: {
                            conditions: [
                                ['${feature["building"]} === null', 'color("white")'],
                                ['${feature["building"]} !== null', 'color("lightgray", 0.9)'],
                                ['true', 'color("white")']
                            ]
                        }
                    });
                    
                    console.log('‚úÖ Photorealistic 3D Tiles loaded');
                } catch (error) {
                    console.log('Using fallback building visualization');
                    this.createFallbackBuildings();
                }
            }
            
            // Fallback building system
            createFallbackBuildings() {
                const cities = [
                    { name: 'New York', lon: -74.006, lat: 40.7128 },
                    { name: 'London', lon: -0.1276, lat: 51.5074 },
                    { name: 'Paris', lon: 2.3522, lat: 48.8566 },
                    { name: 'Tokyo', lon: 139.6917, lat: 35.6895 }
                ];
                
                cities.forEach(city => {
                    // Create procedural city blocks
                    for (let i = 0; i < 20; i++) {
                        const offsetLon = (Math.random() - 0.5) * 0.02;
                        const offsetLat = (Math.random() - 0.5) * 0.02;
                        const height = Math.random() * 200 + 50;
                        
                        this.viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(
                                city.lon + offsetLon, 
                                city.lat + offsetLat, 
                                height / 2
                            ),
                            box: {
                                dimensions: new Cesium.Cartesian3(100, 100, height),
                                material: Cesium.Color.LIGHTGRAY.withAlpha(0.8),
                                outline: true,
                                outlineColor: Cesium.Color.DARKGRAY
                            }
                        });
                    }
                });
            }
            
            // Advanced terrain with bathymetry
            async initializeAdvancedTerrain() {
                try {
                    console.log('üèîÔ∏è Initializing Advanced Terrain...');
                    
                    // Cesium World Terrain with all features
                    const terrainProvider = await Cesium.createWorldTerrainAsync({
                        requestWaterMask: true,
                        requestVertexNormals: true,
                        requestMetadata: true
                    });
                    
                    this.viewer.terrainProvider = terrainProvider;
                    
                    // Add Cesium World Bathymetry for underwater terrain
                    const bathymetryProvider = new Cesium.CesiumTerrainProvider({
                        url: 'https://assets.cesium.com/ion/1/assets/1/tileset.json',
                        requestWaterMask: true
                    });
                    
                    // Enable terrain lighting and shadows
                    this.viewer.scene.globe.enableLighting = true;
                    this.viewer.scene.globe.dynamicAtmosphereLighting = true;
                    this.viewer.scene.globe.atmosphereLightIntensity = 10.0;
                    
                    // Enhanced water appearance
                    this.viewer.scene.globe.oceanNormalMapUrl = 'https://assets.cesium.com/ion/1/assets/1/images/normalMap.jpg';
                    this.viewer.scene.globe.showWaterEffect = true;
                    
                    // Terrain exaggeration for dramatic effect
                    this.viewer.scene.globe.terrainExaggeration = 1.5;
                    this.viewer.scene.globe.terrainExaggerationRelativeHeight = 0.0;
                    
                    console.log('‚úÖ Advanced Terrain loaded');
                } catch (error) {
                    console.log('Using basic terrain with enhancements');
                    this.enhanceBasicTerrain();
                }
            }
            
            enhanceBasicTerrain() {
                // Enhanced basic terrain settings
                this.viewer.scene.globe.enableLighting = true;
                this.viewer.scene.globe.dynamicAtmosphereLighting = true;
                this.viewer.scene.globe.showWaterEffect = true;
                this.viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#1e3d59');
            }
            
            // Weather system integration
            async initializeWeatherSystem() {
                console.log('üå¶Ô∏è Initializing Weather System...');
                
                this.weatherSystem = {
                    precipitation: null,
                    windStreams: [],
                    temperatureOverlay: null,
                    cloudLayers: []
                };
                
                // Create dynamic cloud system
                this.createCloudLayers();
                
                // Add precipitation effects
                this.createPrecipitationSystem();
                
                // Wind stream visualization
                this.createWindStreams();
                
                // Temperature overlay
                this.createTemperatureOverlay();
                
                console.log('‚úÖ Weather System initialized');
            }
            
            createCloudLayers() {
                // Dynamic cloud coverage using particle system
                const cloudPositions = [];
                const cloudColors = [];
                
                for (let i = 0; i < 1000; i++) {
                    const lon = (Math.random() - 0.5) * 360;
                    const lat = (Math.random() - 0.5) * 180;
                    const height = 8000 + Math.random() * 4000;
                    
                    cloudPositions.push(Cesium.Cartesian3.fromDegrees(lon, lat, height));
                    cloudColors.push(Cesium.Color.WHITE.withAlpha(0.6));
                }
                
                // Cloud particle system
                const cloudSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.WHITE.withAlpha(0.7),
                    endColor: Cesium.Color.WHITE.withAlpha(0.0),
                    startScale: 50.0,
                    endScale: 100.0,
                    minimumParticleLife: 5.0,
                    maximumParticleLife: 10.0,
                    minimumSpeed: 1.0,
                    maximumSpeed: 4.0,
                    imageSize: new Cesium.Cartesian2(100, 100),
                    emissionRate: 50.0,
                    lifetime: 16.0,
                    emitter: new Cesium.SphereEmitter(5000000.0)
                }));
                
                this.weatherSystem.cloudLayers.push(cloudSystem);
            }
            
            createPrecipitationSystem() {
                // Rain/snow particle system
                const precipitationSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.LIGHTBLUE.withAlpha(0.8),
                    endColor: Cesium.Color.BLUE.withAlpha(0.2),
                    startScale: 2.0,
                    endScale: 1.0,
                    minimumParticleLife: 1.0,
                    maximumParticleLife: 3.0,
                    minimumSpeed: 10.0,
                    maximumSpeed: 20.0,
                    imageSize: new Cesium.Cartesian2(2, 10),
                    emissionRate: 200.0,
                    lifetime: 16.0,
                    emitter: new Cesium.BoxEmitter(new Cesium.Cartesian3(100000, 100000, 1000))
                }));
                
                this.weatherSystem.precipitation = precipitationSystem;
            }
            
            createWindStreams() {
                // Wind flow visualization using polylines
                const windData = [
                    { start: [-120, 35], end: [-80, 40], strength: 'strong' },
                    { start: [0, 50], end: [40, 45], strength: 'moderate' },
                    { start: [100, 30], end: [140, 35], strength: 'light' },
                    { start: [-30, -20], end: [20, -15], strength: 'strong' }
                ];
                
                windData.forEach(wind => {
                    const positions = [];
                    const colors = [];
                    const steps = 20;
                    
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const lon = Cesium.Math.lerp(wind.start[0], wind.end[0], t);
                        const lat = Cesium.Math.lerp(wind.start[1], wind.end[1], t) + Math.sin(t * Math.PI * 4) * 2;
                        const height = 5000 + Math.sin(t * Math.PI * 2) * 2000;
                        
                        positions.push(Cesium.Cartesian3.fromDegrees(lon, lat, height));
                        
                        const alpha = wind.strength === 'strong' ? 0.8 : wind.strength === 'moderate' ? 0.6 : 0.4;
                        colors.push(Cesium.Color.CYAN.withAlpha(alpha));
                    }
                    
                    const windStream = this.viewer.entities.add({
                        polyline: {
                            positions: positions,
                            width: wind.strength === 'strong' ? 8 : wind.strength === 'moderate' ? 5 : 3,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.2,
                                color: Cesium.Color.CYAN.withAlpha(0.7)
                            }),
                            clampToGround: false,
                            height: 1000
                        }
                    });
                    
                    this.weatherSystem.windStreams.push(windStream);
                });
            }
            
            createTemperatureOverlay() {
                // Temperature visualization using color-coded regions
                const temperatureRegions = [
                    { bounds: [-180, -60, 180, -30], temp: -10, color: Cesium.Color.BLUE },
                    { bounds: [-180, -30, 180, 0], temp: 15, color: Cesium.Color.CYAN },
                    { bounds: [-180, 0, 180, 30], temp: 25, color: Cesium.Color.YELLOW },
                    { bounds: [-180, 30, 180, 60], temp: 30, color: Cesium.Color.ORANGE },
                    { bounds: [-180, 60, 180, 90], temp: -5, color: Cesium.Color.LIGHTBLUE }
                ];
                
                temperatureRegions.forEach(region => {
                    const temperatureZone = this.viewer.entities.add({
                        rectangle: {
                            coordinates: Cesium.Rectangle.fromDegrees(
                                region.bounds[0], region.bounds[1], 
                                region.bounds[2], region.bounds[3]
                            ),
                            material: region.color.withAlpha(0.3),
                            height: 100000,
                            outline: false
                        }
                    });
                });
            }
            
            // Advanced particle systems
            async initializeParticleSystem() {
                console.log('‚ú® Initializing Advanced Particle Systems...');
                
                this.particleSystem = {
                    aurora: null,
                    cityLights: [],
                    atmosphericEffects: []
                };
                
                // Aurora Borealis effect
                this.createAuroraEffect();
                
                // City lights at night
                this.createCityLights();
                
                // Atmospheric scattering particles
                this.createAtmosphericEffects();
                
                console.log('‚úÖ Particle Systems initialized');
            }
            
            createAuroraEffect() {
                // Aurora particle system for polar regions
                const auroraSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.GREEN.withAlpha(0.8),
                    endColor: Cesium.Color.PURPLE.withAlpha(0.2),
                    startScale: 100.0,
                    endScale: 200.0,
                    minimumParticleLife: 8.0,
                    maximumParticleLife: 15.0,
                    minimumSpeed: 2.0,
                    maximumSpeed: 8.0,
                    imageSize: new Cesium.Cartesian2(50, 200),
                    emissionRate: 30.0,
                    lifetime: 20.0,
                    emitter: new Cesium.BoxEmitter(new Cesium.Cartesian3(2000000, 100000, 500000)),
                    modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
                        Cesium.Cartesian3.fromDegrees(0, 75, 200000)
                    )
                }));
                
                this.particleSystem.aurora = auroraSystem;
            }
            
            createCityLights() {
                const majorCities = [
                    { name: 'New York', lon: -74.006, lat: 40.7128 },
                    { name: 'London', lon: -0.1276, lat: 51.5074 },
                    { name: 'Tokyo', lon: 139.6917, lat: 35.6895 },
                    { name: 'Paris', lon: 2.3522, lat: 48.8566 },
                    { name: 'Sydney', lon: 151.2093, lat: -33.8688 }
                ];
                
                majorCities.forEach(city => {
                    // City glow effect
                    const cityGlow = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(city.lon, city.lat, 1000),
                        ellipse: {
                            semiMinorAxis: 50000,
                            semiMajorAxis: 50000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.3 + Math.sin(time * 0.5) * 0.2;
                                    return Cesium.Color.YELLOW.withAlpha(alpha);
                                }, false)
                            ),
                            height: 0
                        }
                    });
                    
                    this.particleSystem.cityLights.push(cityGlow);
                });
            }
            
            createAtmosphericEffects() {
                // Atmospheric haze and scattering
                const atmosphericHaze = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                    image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                    startColor: Cesium.Color.WHITE.withAlpha(0.1),
                    endColor: Cesium.Color.BLUE.withAlpha(0.05),
                    startScale: 200.0,
                    endScale: 500.0,
                    minimumParticleLife: 20.0,
                    maximumParticleLife: 40.0,
                    minimumSpeed: 0.5,
                    maximumSpeed: 2.0,
                    imageSize: new Cesium.Cartesian2(200, 200),
                    emissionRate: 10.0,
                    lifetime: 60.0,
                    emitter: new Cesium.SphereEmitter(6500000.0)
                }));
                
                this.particleSystem.atmosphericEffects.push(atmosphericHaze);
            }
            
            // Dynamic lighting system
            async initializeDynamicLighting() {
                console.log('‚òÄÔ∏è Initializing Dynamic Lighting...');
                
                this.lightingSystem = {
                    sunPosition: null,
                    moonPosition: null,
                    dynamicShadows: true,
                    atmosphericScattering: true
                };
                
                // Enable advanced lighting
                this.viewer.scene.globe.enableLighting = true;
                this.viewer.scene.globe.dynamicAtmosphereLighting = true;
                this.viewer.scene.globe.atmosphereLightIntensity = 20.0;
                this.viewer.scene.globe.atmosphereHueShift = 0.1;
                this.viewer.scene.globe.atmosphereSaturationShift = 0.1;
                this.viewer.scene.globe.atmosphereBrightnessShift = 0.1;
                
                // Dynamic shadows
                this.viewer.shadows = true;
                this.viewer.terrainShadows = Cesium.ShadowMode.ENABLED;
                
                // Enhanced sky atmosphere
                this.viewer.scene.skyAtmosphere.hueShift = 0.1;
                this.viewer.scene.skyAtmosphere.saturationShift = 0.1;
                this.viewer.scene.skyAtmosphere.brightnessShift = 0.1;
                
                // Sun and moon positioning
                this.setupCelestialBodies();
                
                // Day/night cycle
                this.startDayNightCycle();
                
                console.log('‚úÖ Dynamic Lighting initialized');
            }
            
            setupCelestialBodies() {
                // Enhanced sun
                this.viewer.scene.sun.show = true;
                this.viewer.scene.sun.glowFactor = 2.0;
                
                // Enhanced moon
                this.viewer.scene.moon.show = true;
                this.viewer.scene.moon.textureUrl = 'https://assets.cesium.com/ion/1/assets/1/images/moon.jpg';
                
                // Stars
                this.viewer.scene.skyBox.show = true;
                this.viewer.scene.skyBox.sources = {
                    positiveX: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_positive_x.jpg',
                    negativeX: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_negative_x.jpg',
                    positiveY: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_positive_y.jpg',
                    negativeY: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_negative_y.jpg',
                    positiveZ: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_positive_z.jpg',
                    negativeZ: 'https://assets.cesium.com/ion/1/assets/1/images/starmap_negative_z.jpg'
                };
            }
            
            startDayNightCycle() {
                // Accelerated day/night cycle for demo
                setInterval(() => {
                    const currentTime = this.viewer.clock.currentTime;
                    const newTime = Cesium.JulianDate.addMinutes(currentTime, 10, new Cesium.JulianDate());
                    this.viewer.clock.currentTime = newTime;
                }, 1000); // Update every second, advance 10 minutes
            }
            
            // Ocean effects system
            async initializeOceanEffects() {
                console.log('üåä Initializing Ocean Effects...');
                
                this.oceanSystem = {
                    waveAnimation: true,
                    underwaterFog: true,
                    caustics: true
                };
                
                // Enhanced ocean rendering
                this.viewer.scene.globe.showWaterEffect = true;
                this.viewer.scene.globe.oceanNormalMapUrl = 'https://assets.cesium.com/ion/1/assets/1/images/waterNormals.jpg';
                
                // Underwater fog effect
                this.viewer.scene.fog.enabled = true;
                this.viewer.scene.fog.density = 0.0002;
                this.viewer.scene.fog.screenSpaceErrorFactor = 2.0;
                
                // Ocean wave animation
                this.animateOceanWaves();
                
                // Underwater caustics simulation
                this.createUnderwaterCaustics();
                
                console.log('‚úÖ Ocean Effects initialized');
            }
            
            animateOceanWaves() {
                // Animate ocean normal map for wave effect
                let waveTime = 0;
                const animateWaves = () => {
                    waveTime += 0.01;
                    
                    // This would normally update ocean shader uniforms
                    // For demo purposes, we'll use a simple material animation
                    if (this.viewer.scene.globe.oceanNormalMapUrl) {
                        // Ocean animation would go here in a full implementation
                    }
                    
                    requestAnimationFrame(animateWaves);
                };
                animateWaves();
            }
            
            createUnderwaterCaustics() {
                // Underwater light caustics effect using entities
                const causticsPositions = [];
                for (let i = 0; i < 50; i++) {
                    const lon = (Math.random() - 0.5) * 360;
                    const lat = (Math.random() - 0.5) * 180;
                    const depth = -Math.random() * 1000 - 100;
                    
                    const caustic = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(lon, lat, depth),
                        ellipse: {
                            semiMinorAxis: Math.random() * 100 + 50,
                            semiMajorAxis: Math.random() * 100 + 50,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.2 + Math.sin(time * 2 + i) * 0.1;
                                    return Cesium.Color.CYAN.withAlpha(alpha);
                                }, false)
                            ),
                            height: depth
                        }
                    });
                    
                    causticsPositions.push(caustic);
                }
            }
            
            // Post-processing effects
            async initializePostProcessing() {
                console.log('üé® Initializing Post-Processing Effects...');
                
                // Bloom effect
                this.viewer.scene.postProcessStages.add(Cesium.PostProcessStageLibrary.createBloomStage());
                
                // Depth of field
                const depthOfField = Cesium.PostProcessStageLibrary.createDepthOfFieldStage();
                this.viewer.scene.postProcessStages.add(depthOfField);
                
                // Color grading
                const colorGrading = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        varying vec2 v_textureCoordinates;
                        
                        void main() {
                            vec4 color = texture2D(colorTexture, v_textureCoordinates);
                            
                            // Enhanced saturation and contrast
                            color.rgb = mix(vec3(dot(color.rgb, vec3(0.299, 0.587, 0.114))), color.rgb, 1.2);
                            color.rgb = pow(color.rgb, vec3(0.9));
                            
                            gl_FragColor = color;
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(colorGrading);
                
                // Atmospheric perspective
                const atmosphericPerspective = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        uniform sampler2D depthTexture;
                        varying vec2 v_textureCoordinates;
                        
                        void main() {
                            vec4 color = texture2D(colorTexture, v_textureCoordinates);
                            float depth = texture2D(depthTexture, v_textureCoordinates).r;
                            
                            // Add atmospheric haze based on depth
                            vec3 fogColor = vec3(0.7, 0.8, 1.0);
                            float fogFactor = 1.0 - exp(-depth * 0.00001);
                            color.rgb = mix(color.rgb, fogColor, fogFactor * 0.3);
                            
                            gl_FragColor = color;
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(atmosphericPerspective);
                
                console.log('‚úÖ Post-Processing Effects initialized');
            }
            
            // Toggle weather effects
            toggleWeatherEffects(enabled) {
                if (!this.weatherSystem) return;
                
                this.weatherSystem.cloudLayers.forEach(cloud => {
                    cloud.show = enabled;
                });
                
                if (this.weatherSystem.precipitation) {
                    this.weatherSystem.precipitation.show = enabled;
                }
                
                this.weatherSystem.windStreams.forEach(wind => {
                    wind.show = enabled;
                });
            }
            
            // Toggle particle effects
            toggleParticleEffects(enabled) {
                if (!this.particleSystem) return;
                
                if (this.particleSystem.aurora) {
                    this.particleSystem.aurora.show = enabled;
                }
                
                this.particleSystem.cityLights.forEach(light => {
                    light.show = enabled;
                });
                
                this.particleSystem.atmosphericEffects.forEach(effect => {
                    effect.show = enabled;
                });
            }
            
            // Toggle ocean effects
            toggleOceanEffects(enabled) {
                this.viewer.scene.globe.showWaterEffect = enabled;
                this.viewer.scene.fog.enabled = enabled;
            }
            
            // Performance optimization
            optimizeForPerformance() {
                // Reduce particle counts for better performance
                this.viewer.scene.fog.density = 0.0001;
                
                // Optimize terrain detail
                this.viewer.scene.globe.maximumScreenSpaceError = 2;
                this.viewer.scene.globe.tileCacheSize = 100;
                
                // Reduce post-processing quality
                this.viewer.scene.postProcessStages.removeAll();
                this.viewer.scene.postProcessStages.add(Cesium.PostProcessStageLibrary.createBloomStage());
                
                console.log('üöÄ Performance optimized');
            }
            
            // Enhanced coordinate validation with stricter bounds
            validateCoordinates(lon, lat) {
                // More robust longitude normalization
                while (lon > 180) lon -= 360;
                while (lon < -180) lon += 360;
                
                // Ensure we're well within bounds (add small buffer for floating point precision)
                lon = Math.max(-179.99, Math.min(179.99, lon));
                lat = Math.max(-89.99, Math.min(89.99, lat));
                
                return { lon, lat };
            }
            
            // Safe Rectangle creation with validation
            createSafeRectangle(west, south, east, north) {
                try {
                    // Validate all corners
                    const sw = this.validateCoordinates(west, south);
                    const ne = this.validateCoordinates(east, north);
                    
                    // Ensure west < east and south < north
                    const finalWest = Math.min(sw.lon, ne.lon);
                    const finalEast = Math.max(sw.lon, ne.lon);
                    const finalSouth = Math.min(sw.lat, ne.lat);
                    const finalNorth = Math.max(sw.lat, ne.lat);
                    
                    return Cesium.Rectangle.fromDegrees(finalWest, finalSouth, finalEast, finalNorth);
                } catch (error) {
                    console.warn('Rectangle creation failed, using default:', error);
                    // Return a safe default rectangle
                    return Cesium.Rectangle.fromDegrees(-1, -1, 1, 1);
                }
            }
            
            // Safe entity creation wrapper
            createSafeEntity(entityOptions) {
                try {
                    return this.viewer.entities.add(entityOptions);
                } catch (error) {
                    console.warn('Entity creation failed:', error);
                    return null;
                }
            }
            
            createStuckCargoShips(positions) {
                // Create cargo ships stuck at sea with safe coordinates
                for (let i = 0; i < positions.length - 2; i += 4) {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(positions[i], positions[i + 1]);
                        
                        const ship = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                            rectangle: {
                                coordinates: this.createSafeRectangle(
                                    coords.lon - 0.05, coords.lat - 0.02,
                                    coords.lon + 0.05, coords.lat + 0.02
                                ),
                                material: Cesium.Color.GRAY,
                                height: 0,
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create cargo ship at position ${i}:`, error);
                    }
                }
            }
            
            // Fix all functions that create rectangles or use coordinates
            createTSMCFacilities() {
                const tsmcLocations = [
                    { lon: 120.9605, lat: 24.7736, name: "Fab 18 (3nm)" },
                    { lon: 120.3397, lat: 24.1469, name: "Fab 15 (7nm)" },
                    { lon: 120.9777, lat: 24.8138, name: "Fab 12 (28nm)" }
                ];
                
                tsmcLocations.forEach((fab, i) => {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(fab.lon, fab.lat);
                        
                        // Create glowing fab facility
                        const facility = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 100),
                            box: {
                                dimensions: new Cesium.Cartesian3(500, 300, 50),
                                material: new Cesium.ColorMaterialProperty(
                                    new Cesium.CallbackProperty(() => {
                                        const time = Date.now() / 1000;
                                        const alpha = 0.7 + Math.sin(time * 2 + i) * 0.3;
                                        return Cesium.Color.CYAN.withAlpha(alpha);
                                    }, false)
                                ),
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            },
                            label: {
                                text: fab.name,
                                font: '12pt monospace',
                                fillColor: Cesium.Color.WHITE,
                                outlineColor: Cesium.Color.BLACK,
                                outlineWidth: 2,
                                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                pixelOffset: new Cesium.Cartesian2(0, -50)
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create TSMC facility ${fab.name}:`, error);
                    }
                });
            }
            
            createNavalBlockade() {
                // Chinese naval positions - validated coordinates
                const navalPositions = [
                    { lon: 119.5, lat: 25.2 }, { lon: 120.2, lat: 25.8 },
                    { lon: 121.8, lat: 24.5 }, { lon: 121.2, lat: 23.8 },
                    { lon: 119.8, lat: 23.5 }, { lon: 118.9, lat: 24.1 }
                ];
                
                navalPositions.forEach((pos, i) => {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(pos.lon, pos.lat);
                        
                        // Create naval vessels
                        const vessel = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                            ellipse: {
                                semiMinorAxis: 2000,
                                semiMajorAxis: 4000,
                                material: Cesium.Color.RED.withAlpha(0.8),
                                outline: true,
                                outlineColor: Cesium.Color.DARKRED
                            }
                        });
                        
                        // Add radar coverage circles
                        const radarCoverage = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                            ellipse: {
                                semiMinorAxis: 50000,
                                semiMajorAxis: 50000,
                                material: new Cesium.ColorMaterialProperty(
                                    new Cesium.CallbackProperty(() => {
                                        const time = Date.now() / 1000;
                                        const alpha = 0.2 + Math.sin(time * 3 + i) * 0.1;
                                        return Cesium.Color.RED.withAlpha(alpha);
                                    }, false)
                                )
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create naval vessel at position ${i}:`, error);
                    }
                });
                
                // Shipping lane blockade - fixed coordinates
                try {
                    const blockadeCoords = [
                        118.0, 22.0, 122.0, 26.0, 124.0, 24.0, 120.0, 20.0, 118.0, 22.0
                    ];
                    
                    // Validate all coordinates
                    const validatedCoords = [];
                    for (let i = 0; i < blockadeCoords.length; i += 2) {
                        const coords = this.validateCoordinates(blockadeCoords[i], blockadeCoords[i + 1]);
                        validatedCoords.push(coords.lon, coords.lat);
                    }
                    
                    const blockedShipping = this.createSafeEntity({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArray(validatedCoords),
                            width: 10,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.3,
                                color: Cesium.Color.RED
                            }),
                            clampToGround: false,
                            height: 1000
                        }
                    });
                } catch (error) {
                    console.warn('Failed to create shipping blockade:', error);
                }
            }
            
            createDisruptedShipping() {
                // Major shipping routes now blocked or delayed
                const shippingRoutes = [
                    { 
                        route: [121, 25, 140, 35, 179, 40, -150, 45, -120, 35], // Fixed to avoid 180¬∞ crossing
                        status: "blocked",
                        name: "Trans-Pacific Route"
                    },
                    { 
                        route: [121, 25, 103, 1, 80, 10, 60, 25, 45, 30], 
                        status: "delayed",
                        name: "Asia-Middle East Route"
                    },
                    { 
                        route: [121, 25, 100, -10, 80, -20, 20, -35, 0, 0], 
                        status: "rerouting",
                        name: "Asia-Europe Route"
                    }
                ];
                
                shippingRoutes.forEach(route => {
                    try {
                        // Validate all coordinates in route
                        const validatedRoute = [];
                        for (let i = 0; i < route.route.length; i += 2) {
                            const coords = this.validateCoordinates(route.route[i], route.route[i + 1]);
                            validatedRoute.push(coords.lon, coords.lat);
                        }
                        
                        const color = route.status === "blocked" ? Cesium.Color.RED :
                                     route.status === "delayed" ? Cesium.Color.ORANGE :
                                     Cesium.Color.YELLOW;
                        
                        const shippingLine = this.createSafeEntity({
                            polyline: {
                                positions: Cesium.Cartesian3.fromDegreesArray(validatedRoute),
                                width: 6,
                                material: new Cesium.PolylineGlowMaterialProperty({
                                    glowPower: 0.2,
                                    color: color.withAlpha(0.8)
                                }),
                                clampToGround: false,
                                height: 10000
                            }
                        });
                        
                        // Add animated cargo ships stuck in routes
                        if (route.status === "blocked") {
                            this.createStuckCargoShips(validatedRoute);
                        }
                    } catch (error) {
                        console.warn(`Failed to create shipping route ${route.name}:`, error);
                    }
                });
            }
            
            createSmokeEffect(position) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    // Industrial smoke/shutdown effect
                    const smokeSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                        image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                        startColor: Cesium.Color.GRAY.withAlpha(0.8),
                        endColor: Cesium.Color.BLACK.withAlpha(0.1),
                        startScale: 20.0,
                        endScale: 50.0,
                        minimumParticleLife: 3.0,
                        maximumParticleLife: 6.0,
                        minimumSpeed: 2.0,
                        maximumSpeed: 8.0,
                        imageSize: new Cesium.Cartesian2(25, 25),
                        emissionRate: 30.0,
                        lifetime: 8.0,
                        emitter: new Cesium.CircleEmitter(5000.0),
                        modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
                            Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 500)
                        )
                    }));
                    
                    // Remove after 8 seconds
                    setTimeout(() => {
                        try {
                            this.viewer.scene.primitives.remove(smokeSystem);
                        } catch (e) {
                            console.warn('Failed to remove smoke system:', e);
                        }
                    }, 8000);
                } catch (error) {
                    console.warn('Failed to create smoke effect:', error);
                }
            }
            
            createFinancialCrisis(position, type) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    const colors = {
                        market: Cesium.Color.RED,
                        currency: Cesium.Color.ORANGE,
                        banking: Cesium.Color.PURPLE,
                        central_bank: Cesium.Color.BLUE,
                        controls: Cesium.Color.YELLOW
                    };
                    
                    // Financial crisis visualization
                    const crisis = this.createSafeEntity({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                        ellipse: {
                            semiMinorAxis: 100000,
                            semiMajorAxis: 100000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.4 + Math.sin(time * 4) * 0.3;
                                    return colors[type].withAlpha(alpha);
                                }, false)
                            ),
                            outline: true,
                            outlineColor: colors[type]
                        }
                    });
                    
                    // Add pulsing effect
                    this.createPulsingEffect([coords.lon, coords.lat], colors[type]);
                } catch (error) {
                    console.warn('Failed to create financial crisis visualization:', error);
                }
            }
            
            createDataStreamAttack(targetPos) {
                try {
                    // Validate target coordinates
                    const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                    
                    // Create attack vector lines from various origins
                    const attackOrigins = [
                        [116.4074, 39.9042], // Beijing
                        [37.6176, 55.7558],  // Moscow
                        [55.2708, 25.2048]   // Dubai (proxy)
                    ];
                    
                    attackOrigins.forEach(origin => {
                        try {
                            // Validate origin coordinates
                            const originCoords = this.validateCoordinates(origin[0], origin[1]);
                            
                            const attackVector = this.createSafeEntity({
                                polyline: {
                                    positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                        originCoords.lon, originCoords.lat, 20000,
                                        targetCoords.lon, targetCoords.lat, 5000
                                    ]),
                                    width: 4,
                                    material: new Cesium.PolylineGlowMaterialProperty({
                                        glowPower: 0.3,
                                        color: Cesium.Color.MAGENTA.withAlpha(0.8)
                                    })
                                }
                            });
                        } catch (error) {
                            console.warn('Failed to create attack vector:', error);
                        }
                    });
                } catch (error) {
                    console.warn('Failed to create data stream attack:', error);
                }
            }
            
            createRefugeeCamp(position) {
                try {
                    // Validate coordinates and add small offset for camp location
                    const coords = this.validateCoordinates(position[0] + 0.1, position[1] + 0.1);
                    
                    // Refugee camp visualization
                    const camp = this.createSafeEntity({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                        ellipse: {
                            semiMinorAxis: 15000,
                            semiMajorAxis: 25000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.5 + Math.sin(time) * 0.2;
                                    return Cesium.Color.BROWN.withAlpha(alpha);
                                }, false)
                            ),
                            outline: true,
                            outlineColor: Cesium.Color.WHITE
                        }
                    });
                } catch (error) {
                    console.warn('Failed to create refugee camp:', error);
                }
            }
            
            createASATAttack(targetPos) {
                try {
                    // Anti-satellite weapon launch
                    const launchSite = [116.4074, 39.9042, 0]; // China
                    
                    // Validate launch site coordinates
                    const launchCoords = this.validateCoordinates(launchSite[0], launchSite[1]);
                    
                    // Validate target coordinates (space coordinates don't need validation but we'll be safe)
                    const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                    
                    // Missile trajectory to satellite
                    const asatMissile = this.createSafeEntity({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                launchCoords.lon, launchCoords.lat, launchSite[2],
                                targetCoords.lon, targetCoords.lat, targetPos[2]
                            ]),
                            width: 5,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.4,
                                color: Cesium.Color.RED.withAlpha(0.9)
                            })
                        }
                    });
                    
                    // Satellite explosion
                    setTimeout(() => {
                        this.createExplosion(
                            Cesium.Cartesian3.fromDegrees(targetCoords.lon, targetCoords.lat, targetPos[2]),
                            0.8
                        );
                    }, 2000);
                } catch (error) {
                    console.warn('Failed to create ASAT attack:', error);
                }
            }
            
            createPulsingEffect(position, color) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    const pulseEffect = this.createSafeEntity({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 2000),
                        ellipse: {
                            semiMinorAxis: 50000,
                            semiMajorAxis: 50000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const scale = 1 + Math.sin(time * 6) * 0.5;
                                    const alpha = 0.3 + Math.sin(time * 6) * 0.2;
                                    return color.withAlpha(alpha);
                                }, false)
                            )
                        }
                    });
                    
                    // Remove after 5 seconds
                    setTimeout(() => {
                        try {
                            if (pulseEffect) {
                                this.viewer.entities.remove(pulseEffect);
                            }
                        } catch (e) {
                            console.warn('Failed to remove pulse effect:', e);
                        }
                    }, 5000);
                } catch (error) {
                    console.warn('Failed to create pulsing effect:', error);
                }
            }
        }
        
        // Initialize advanced globe enrichment
        let advancedGlobe = null;
        
        // Enhanced initialization function
        async function initializeEnhancedGame() {
            try {
                // Initialize basic game first
                await initializeGame();
                
                // Initialize country borders
                countryBorders = new CountryBordersSystem(viewer);
                await countryBorders.initialize();
                
                // Initialize advanced globe features
                advancedGlobe = new AdvancedGlobeEnrichment(viewer);
                await advancedGlobe.initialize();
                
                // Add control panel for toggling features
                createAdvancedControlPanel();
                
                console.log('üåç Enhanced Globe with Country Borders Ready!');
                
            } catch (error) {
                console.error('Enhanced initialization failed:', error);
                // Fallback to basic initialization
                await initializeGame();
            }
        }
        
        // Control panel for advanced features
        function createAdvancedControlPanel() {
            const controlPanel = document.createElement('div');
            controlPanel.style.cssText = `
                position: absolute; top: 100px; right: 20px; width: 280px;
                background: rgba(0,0,0,0.8); color: white; padding: 15px;
                border-radius: 10px; font-family: 'SF Pro Text', sans-serif;
                border: 1px solid #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.3);
            `;
            
            controlPanel.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #00ff88;">üåç Globe Controls</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="borders-toggle" checked>
                        <span>üó∫Ô∏è Country Borders</span>
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="weather-toggle" checked>
                        <span>üå¶Ô∏è Weather Effects</span>
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="particles-toggle" checked>
                        <span>‚ú® Particle Effects</span>
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="ocean-toggle" checked>
                        <span>üåä Ocean Effects</span>
                    </label>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="performance-toggle">
                        <span>üöÄ Performance Mode</span>
                    </label>
                </div>
                <button id="reset-view" style="width: 100%; padding: 8px; background: #00ff88; border: none; border-radius: 5px; color: black; font-weight: bold; margin-bottom: 8px;">
                    üè† Reset View
                </button>
                <button id="show-alliances" style="width: 100%; padding: 8px; background: #4444ff; border: none; border-radius: 5px; color: white; font-weight: bold;">
                    üõ°Ô∏è Show Alliances
                </button>
            `;
            
            document.body.appendChild(controlPanel);
            
            // Event listeners
            document.getElementById('borders-toggle').addEventListener('change', (e) => {
                if (countryBorders && countryBorders.countryBorders) {
                    countryBorders.countryBorders.show = e.target.checked;
                }
            });
            
            document.getElementById('weather-toggle').addEventListener('change', (e) => {
                if (advancedGlobe) advancedGlobe.toggleWeatherEffects(e.target.checked);
            });
            
            document.getElementById('particles-toggle').addEventListener('change', (e) => {
                if (advancedGlobe) advancedGlobe.toggleParticleEffects(e.target.checked);
            });
            
            document.getElementById('ocean-toggle').addEventListener('change', (e) => {
                if (advancedGlobe) advancedGlobe.toggleOceanEffects(e.target.checked);
            });
            
            document.getElementById('performance-toggle').addEventListener('change', (e) => {
                if (advancedGlobe && e.target.checked) advancedGlobe.optimizeForPerformance();
            });
            
            document.getElementById('reset-view').addEventListener('click', () => {
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 25000000),
                    orientation: {
                        heading: 0,
                        pitch: -Math.PI / 2,
                        roll: 0
                    }
                });
            });
            
            document.getElementById('show-alliances').addEventListener('click', () => {
                if (countryBorders) {
                    // Show current alliances
                    countryBorders.showAllianceFormation('NATO', 
                        ['United States', 'United Kingdom', 'France', 'Germany'], 
                        countryBorders.allianceColors.nato
                    );
                    countryBorders.showAllianceFormation('Pacific Alliance', 
                        ['Japan', 'South Korea', 'Australia'], 
                        countryBorders.allianceColors.pacific
                    );
                    countryBorders.highlightCountry('China', 'hostile', 0.4);
                    countryBorders.highlightCountry('Russia', 'hostile', 0.4);
                }
            });
        }
        
        // Update the main initialization to use enhanced version
        async function initializeGame() {
            try {
                console.log('üöÄ Initializing Enhanced Coalitions Globe...');
                
                // Load token from .env or use fallback
                const token = import.meta.env?.VITE_CESIUM_TOKEN || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxMTk3NGQ0YS1jOTgzLTRmMTItODE1ZC04NTU2M2ZhYmExNTAiLCJpZCI6MzIxNzgxLCJpYXQiOjE3NTI2MDQ2ODh9.hcAL5ZNXEpcJTz6OwmNWEcl2ZG1A8afrhHifi80uO4I';
                
                console.log('üîë Using Cesium token:', token.substring(0, 20) + '...');
                Cesium.Ion.defaultAccessToken = token;
                
                // Try creating viewer with terrain first, fallback to basic if it fails
                try {
                    viewer = new Cesium.Viewer('cesiumContainer', {
                        timeline: false,
                        animation: false,
                        baseLayerPicker: false,
                        fullscreenButton: true,
                        homeButton: true,
                        sceneModePicker: false,
                        geocoder: false,
                        navigationHelpButton: false,
                        vrButton: false,
                        requestRenderMode: false,
                        shadows: true,
                        terrainProvider: await Cesium.createWorldTerrainAsync({
                            requestWaterMask: true,
                            requestVertexNormals: true
                        })
                    });
                    console.log('‚úÖ Advanced terrain viewer created');
                } catch (terrainError) {
                    console.log('Using basic viewer');
                    viewer = new Cesium.Viewer('cesiumContainer', {
                        timeline: false,
                        animation: false,
                        baseLayerPicker: false,
                        fullscreenButton: true,
                        homeButton: true,
                        sceneModePicker: false,
                        geocoder: false,
                        navigationHelpButton: false,
                        vrButton: false,
                        requestRenderMode: false,
                        shadows: false
                    });
                }
                
                // Set initial view - proper Earth home view like home button
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 25000000),
                    orientation: {
                        heading: 0,
                        pitch: -Math.PI / 2,
                        roll: 0
                    }
                });
                
                // Override home button to use same view
                viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (e) {
                    e.cancel = true;
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 25000000),
                        orientation: {
                            heading: 0,
                            pitch: -Math.PI / 2,
                            roll: 0
                        },
                        duration: 2
                    });
                });
                
                // Enhanced globe settings for better Earth visibility
                viewer.scene.globe.enableLighting = false;
                viewer.scene.globe.dynamicAtmosphereLighting = false;
                viewer.scene.skyAtmosphere.brightness = 1.0;
                viewer.scene.fog.enabled = false;
                viewer.scene.globe.baseColor = Cesium.Color.BLUE;
                
                // Ensure Earth imagery loads
                viewer.scene.globe.show = true;
                viewer.scene.skyBox.show = true;
                viewer.scene.sun.show = true;
                viewer.scene.moon.show = true;
                
                // Force immediate render
                viewer.scene.requestRender();
                
                // Wait a moment then ensure Earth is visible
                setTimeout(() => {
                    if (viewer.scene.globe.show) {
                        console.log('‚úÖ Earth globe is visible');
                        showNotification('Earth Loaded', 'üåç Globe rendering successfully');
                    } else {
                        console.log('‚ùå Earth globe not visible');
                        showNotification('Loading Issue', '‚ö†Ô∏è Earth not visible - check token');
                    }
                    
                    // Hide loading screen
                    const loadingScreen = document.querySelector('.loading-screen');
                    if (loadingScreen) {
                        loadingScreen.style.opacity = '0';
                        setTimeout(() => loadingScreen.remove(), 1000);
                    }
                }, 2000);
                
                // Initialize trailer mode if requested
                if (isTrailerMode) {
                    setTimeout(() => {
                        if (cinematicTrailer) {
                            cinematicTrailer.start();
                        } else {
                            startTrailerSequence();
                        }
                    }, 3000);
                } else {
                    // Initialize enhanced globe features after basic initialization
                    setTimeout(() => {
                        // Don't call initializeEnhancedGame again - just initialize the enhanced features
                        initializeEnhancedFeatures();
                    }, 2000);
                }
                
                console.log('üéÆ Game initialized successfully');
                
            } catch (error) {
                console.error('‚ùå Game initialization failed:', error);
                
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Failed to load. Please refresh the page.';
                    loadingText.style.color = '#ff4444';
                }
            }
        }
        
        // Separate function for initializing enhanced features (no recursion)
        async function initializeEnhancedFeatures() {
            try {
                console.log('üåç Initializing enhanced features...');
                
                // Initialize country borders
                countryBorders = new CountryBordersSystem(viewer);
                await countryBorders.initialize();
                
                // Initialize advanced globe features
                advancedGlobe = new AdvancedGlobeEnrichment(viewer);
                await advancedGlobe.initialize();
                
                // Add control panel for toggling features
                createAdvancedControlPanel();
                
                console.log('‚úÖ Enhanced features ready!');
                
            } catch (error) {
                console.error('Enhanced features initialization failed:', error);
            }
        }
        
        // EPIC CINEMATIC TRAILER - Full Production Version
        class CinematicTrailer {
            constructor(viewer) {
                this.viewer = viewer;
                this.audioContext = null;
                this.sounds = {};
                this.models = {};
                this.particles = {};
                this.activeAnimations = [];
                this.isPlaying = false;
            }
            
            // Initialize audio system
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Load and setup sounds
                    const soundUrls = {
                        bgMusic: 'https://www.soundjay.com/misc/sounds-misc-29.mp3', // Epic orchestral
                        explosion: 'https://www.soundjay.com/misc/explosion-01.mp3',
                        missile: 'https://www.soundjay.com/misc/whoosh-10.mp3',
                        alert: 'https://www.soundjay.com/misc/bell-ringing-05.mp3',
                        jet: 'https://www.soundjay.com/misc/jet-fly-by-02.mp3'
                    };
                    
                    // Create audio elements with fallback
                    for (let [name, url] of Object.entries(soundUrls)) {
                        const audio = new Audio();
                        audio.crossOrigin = 'anonymous';
                        audio.preload = 'auto';
                        audio.volume = name === 'bgMusic' ? 0.3 : 0.7;
                        if (name === 'bgMusic') audio.loop = true;
                        
                        // Fallback to Web Audio API tones if URLs fail
                        audio.onerror = () => {
                            console.log(`Creating synthetic ${name} sound`);
                            this.sounds[name] = this.createSyntheticSound(name);
                        };
                        
                        audio.oncanplaythrough = () => {
                            this.sounds[name] = audio;
                        };
                        
                        audio.src = url;
                    }
                    
                    console.log('üîä Audio system initialized');
                } catch (error) {
                    console.log('Using synthetic audio fallback');
                    this.createAllSyntheticSounds();
                }
            }
            
            // Create synthetic sounds using Web Audio API
            createSyntheticSound(type) {
                return {
                    play: () => {
                        if (!this.audioContext) return;
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        switch(type) {
                            case 'explosion':
                                oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.5);
                                gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 0.5);
                                break;
                            case 'missile':
                                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                                oscillator.frequency.linearRampToValueAtTime(400, this.audioContext.currentTime + 1);
                                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                                gainNode.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 1);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 1);
                                break;
                            case 'alert':
                                oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 0.2);
                                break;
                            case 'jet':
                                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                                oscillator.frequency.linearRampToValueAtTime(600, this.audioContext.currentTime + 2);
                                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                                gainNode.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 2);
                                oscillator.start();
                                oscillator.stop(this.audioContext.currentTime + 2);
                                break;
                        }
                    }
                };
            }
            
            createAllSyntheticSounds() {
                const soundTypes = ['bgMusic', 'explosion', 'missile', 'alert', 'jet'];
                soundTypes.forEach(type => {
                    this.sounds[type] = this.createSyntheticSound(type);
                });
            }
            
            // Play sound with error handling
            playSound(name) {
                try {
                    if (this.sounds[name] && typeof this.sounds[name].play === 'function') {
                        this.sounds[name].play();
                    }
                } catch (error) {
                    console.log(`Sound ${name} failed, using fallback`);
                }
            }
            
            // Create 3D models
            async create3DModel(type, position, options = {}) {
                const modelUrls = {
                    f35: 'https://sandcastle.cesium.com/SampleData/models/CesiumAir/Cesium_Air.gltf',
                    missile: 'https://sandcastle.cesium.com/SampleData/models/CesiumDrone/CesiumDrone.gltf',
                    ship: 'https://sandcastle.cesium.com/SampleData/models/CesiumMilkTruck/CesiumMilkTruck.gltf'
                };
                
                const entity = this.viewer.entities.add({
                    position: position,
                    orientation: Cesium.Transforms.headingPitchRollQuaternion(
                        position,
                        new Cesium.HeadingPitchRoll(0, 0, 0)
                    ),
                    model: {
                        uri: modelUrls[type] || modelUrls.f35,
                        minimumPixelSize: options.size || 64,
                        maximumScale: options.scale || 10000,
                        scale: options.modelScale || 1.0,
                        color: options.color || Cesium.Color.WHITE,
                        colorBlendMode: Cesium.ColorBlendMode.MIX,
                        colorBlendAmount: options.colorBlend || 0.0
                    }
                });
                
                return entity;
            }
            
            // Create explosion effect with particles
            createExplosion(position, intensity = 1.0) {
                this.playSound('explosion');
                
                // Main explosion sphere
                const explosion = this.viewer.entities.add({
                    position: position,
                    ellipse: {
                        semiMinorAxis: 50000 * intensity,
                        semiMajorAxis: 50000 * intensity,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const alpha = Math.max(0, 1 - (time % 2) / 2);
                                return Cesium.Color.ORANGE.withAlpha(alpha);
                            }, false)
                        ),
                        outline: true,
                        outlineColor: Cesium.Color.RED
                    }
                });
                
                // Particle system simulation with multiple entities
                for (let i = 0; i < 8; i++) {
                    const offset = Math.random() * 100000;
                    const angle = (i / 8) * Math.PI * 2;
                    const particlePos = Cesium.Cartesian3.fromDegrees(
                        Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(position).longitude) + Math.cos(angle) * 0.01,
                        Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(position).latitude) + Math.sin(angle) * 0.01,
                        offset
                    );
                    
                    const particle = this.viewer.entities.add({
                        position: particlePos,
                        ellipse: {
                            semiMinorAxis: 10000,
                            semiMajorAxis: 10000,
                            material: Cesium.Color.YELLOW.withAlpha(0.8)
                        }
                    });
                    
                    // Animate particle
                    setTimeout(() => {
                        this.viewer.entities.remove(particle);
                    }, 2000);
                }
                
                // Remove main explosion after animation
                setTimeout(() => {
                    this.viewer.entities.remove(explosion);
                }, 3000);
                
                // Screen shake effect
                this.screenShake();
                
                return explosion;
            }
            
            // Screen shake effect
            screenShake() {
                const originalTransform = document.body.style.transform;
                let shakeCount = 0;
                const shakeInterval = setInterval(() => {
                    const x = (Math.random() - 0.5) * 10;
                    const y = (Math.random() - 0.5) * 10;
                    document.body.style.transform = `translate(${x}px, ${y}px)`;
                    shakeCount++;
                    
                    if (shakeCount > 10) {
                        clearInterval(shakeInterval);
                        document.body.style.transform = originalTransform;
                    }
                }, 50);
            }
            
            // Animate object along path
            animateObjectPath(entity, startPos, endPos, duration, onComplete) {
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / (duration * 1000), 1);
                    
                    // Smooth easing
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    const currentPos = Cesium.Cartesian3.lerp(startPos, endPos, eased, new Cesium.Cartesian3());
                    entity.position = currentPos;
                    
                    // Add trail effect
                    if (progress < 1) {
                        // Create trail particle
                        const trail = this.viewer.entities.add({
                            position: currentPos,
                            point: {
                                pixelSize: 5,
                                color: Cesium.Color.CYAN.withAlpha(0.6),
                                scaleByDistance: new Cesium.NearFarScalar(1000, 1.0, 100000, 0.0)
                            }
                        });
                        
                        setTimeout(() => this.viewer.entities.remove(trail), 1000);
                        
                        requestAnimationFrame(animate);
                    } else {
                        if (onComplete) onComplete();
                    }
                };
                
                animate();
            }
            
            // Smooth camera transition
            smoothCameraMove(destination, duration, onComplete) {
                this.viewer.camera.flyTo({
                    destination: destination,
                    duration: duration,
                    complete: onComplete,
                    easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT
                });
            }
            
            // Create UI overlay with enhanced effects
            createTrailerUI() {
                const ui = document.createElement('div');
                ui.id = 'cinematic-ui';
                ui.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    pointer-events: none; z-index: 10000; font-family: 'SF Pro Text', sans-serif;
                    background: linear-gradient(45deg, rgba(0,0,0,0.1), rgba(0,0,0,0.3));
                `;
                document.body.appendChild(ui);
                
                // Enhanced voiceover with glow effect
                const voiceover = document.createElement('div');
                voiceover.id = 'voiceover';
                voiceover.style.cssText = `
                    position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
                    background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
                    color: white; padding: 25px 50px; border-radius: 15px;
                    font-size: 28px; text-align: center; font-weight: 600;
                    opacity: 0; transition: all 1s ease;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.1);
                    text-shadow: 0 0 20px rgba(255,255,255,0.5);
                    border: 1px solid rgba(255,255,255,0.2);
                `;
                ui.appendChild(voiceover);
                
                // Enhanced alert system
                const alerts = document.createElement('div');
                alerts.id = 'alert-system';
                alerts.style.cssText = `
                    position: absolute; top: 30px; right: 30px; width: 350px;
                `;
                ui.appendChild(alerts);
                
                // Resource display with animations
                const resources = document.createElement('div');
                resources.id = 'resources';
                resources.style.cssText = `
                    position: absolute; top: 30px; left: 30px;
                    background: rgba(0,0,0,0.8); color: white; padding: 20px;
                    border-radius: 10px; font-family: 'Courier New', monospace;
                    border: 1px solid #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.3);
                `;
                ui.appendChild(resources);
                
                return { ui, voiceover, alerts, resources };
            }
            
            // Show enhanced voiceover
            showVoiceover(text, duration = 4000) {
                const voiceover = document.getElementById('voiceover');
                if (voiceover) {
                    voiceover.textContent = text;
                    voiceover.style.opacity = '1';
                    voiceover.style.transform = 'translateX(-50%) scale(1.05)';
                    
                    setTimeout(() => {
                        voiceover.style.opacity = '0';
                        voiceover.style.transform = 'translateX(-50%) scale(0.95)';
                    }, duration);
                }
            }
            
            // Enhanced alert with sound and animation
            showAlert(text, type = 'danger') {
                this.playSound('alert');
                
                const alerts = document.getElementById('alert-system');
                if (!alerts) return;
                
                const alert = document.createElement('div');
                alert.style.cssText = `
                    background: ${type === 'danger' ? 'linear-gradient(135deg, #ff4444, #cc0000)' : 'linear-gradient(135deg, #00ff88, #00cc66)'};
                    color: white; padding: 15px; margin-bottom: 10px; border-radius: 8px;
                    transform: translateX(100%); transition: transform 0.5s ease;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                    border-left: 4px solid ${type === 'danger' ? '#ffffff' : '#000000'};
                `;
                
                alert.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 12px; height: 12px; background: white; border-radius: 50%; animation: pulse 1s infinite;"></div>
                        <strong>GLOBAL ALERT:</strong> ${text}
                    </div>
                `;
                
                alerts.appendChild(alert);
                
                // Animate in
                setTimeout(() => alert.style.transform = 'translateX(0)', 100);
                
                // Remove after delay
                setTimeout(() => {
                    alert.style.transform = 'translateX(100%)';
                    setTimeout(() => alerts.removeChild(alert), 500);
                }, 4000);
            }
            
            // HYPER-REALISTIC GEOPOLITICAL SCENARIO
            // "The 72-Hour Crisis: When the World's Chips Stop"
            async start() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                
                console.log('üé¨ STARTING HYPER-REALISTIC SCENARIO: "The 72-Hour Crisis"');
                
                // Initialize audio and UI
                await this.initAudio();
                const uiElements = this.createTrailerUI();
                
                // Hide game UI
                document.querySelectorAll('.return-button, .satellite-button, .cesium-toolbar').forEach(el => {
                    if (el) el.style.display = 'none';
                });
                
                // Start background music
                setTimeout(() => this.playSound('bgMusic'), 1000);
                
                // HOUR 0: The Semiconductor Trigger
                this.hourZero();
            }
            
            // Fix coordinate validation issues
            validateCoordinates(lon, lat) {
                // Ensure longitude is within -180 to 180 degrees
                lon = ((lon + 180) % 360 + 360) % 360 - 180;
                // Ensure latitude is within -90 to 90 degrees
                lat = Math.max(-90, Math.min(90, lat));
                return { lon, lat };
            }
            
            // HOUR 0: The Semiconductor Crisis Begins (FIXED)
            hourZero() {
                console.log('üé¨ HOUR 0: The Semiconductor Trigger');
                this.showVoiceover("HOUR 0: Taiwan Strait - A single miscalculation...", 6000);
                
                // Start with peaceful TSMC facilities in Taiwan
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(120.9605, 24.7736, 500000), // Taiwan
                    4,
                    () => {
                        // Show TSMC facilities
                        this.createTSMCFacilities();
                        
                        setTimeout(() => {
                            this.showAlert("BREAKING: Chinese naval exercises escalate near Taiwan", "danger");
                            this.showAlert("TSMC halts production at 3nm fabs", "danger");
                            
                            // Create naval blockade visualization
                            this.createNavalBlockade();
                            
                            // Show immediate market reaction
                            setTimeout(() => {
                                this.showAlert("NASDAQ futures down 8% in after-hours trading", "danger");
                                this.showAlert("Apple, NVIDIA trading halted", "danger");
                                
                                // Move to global impact
                                setTimeout(() => this.hourSix(), 4000);
                            }, 3000);
                        }, 4000);
                    }
                );
            }
            
            // Create TSMC facilities (FIXED)
            createTSMCFacilities() {
                const tsmcLocations = [
                    { lon: 120.9605, lat: 24.7736, name: "Fab 18 (3nm)" },
                    { lon: 120.3397, lat: 24.1469, name: "Fab 15 (7nm)" },
                    { lon: 120.9777, lat: 24.8138, name: "Fab 12 (28nm)" }
                ];
                
                tsmcLocations.forEach((fab, i) => {
                    // Validate coordinates
                    const coords = this.validateCoordinates(fab.lon, fab.lat);
                    
                    // Create glowing fab facility
                    const facility = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 100),
                        box: {
                            dimensions: new Cesium.Cartesian3(500, 300, 50),
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.7 + Math.sin(time * 2 + i) * 0.3;
                                    return Cesium.Color.CYAN.withAlpha(alpha);
                                }, false)
                            ),
                            outline: true,
                            outlineColor: Cesium.Color.WHITE
                        },
                        label: {
                            text: fab.name,
                            font: '12pt monospace',
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -50)
                        }
                    });
                });
            }
            
            // Create naval blockade visualization (FIXED)
            createNavalBlockade() {
                // Chinese naval positions - validated coordinates
                const navalPositions = [
                    { lon: 119.5, lat: 25.2 }, { lon: 120.2, lat: 25.8 },
                    { lon: 121.8, lat: 24.5 }, { lon: 121.2, lat: 23.8 },
                    { lon: 119.8, lat: 23.5 }, { lon: 118.9, lat: 24.1 }
                ];
                
                navalPositions.forEach((pos, i) => {
                    // Validate coordinates
                    const coords = this.validateCoordinates(pos.lon, pos.lat);
                    
                    // Create naval vessels
                    const vessel = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                        ellipse: {
                            semiMinorAxis: 2000,
                            semiMajorAxis: 4000,
                            material: Cesium.Color.RED.withAlpha(0.8),
                            outline: true,
                            outlineColor: Cesium.Color.DARKRED
                        }
                    });
                    
                    // Add radar coverage circles
                    const radarCoverage = this.viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                        ellipse: {
                            semiMinorAxis: 50000,
                            semiMajorAxis: 50000,
                            material: new Cesium.ColorMaterialProperty(
                                new Cesium.CallbackProperty(() => {
                                    const time = Date.now() / 1000;
                                    const alpha = 0.2 + Math.sin(time * 3 + i) * 0.1;
                                    return Cesium.Color.RED.withAlpha(alpha);
                                }, false)
                            )
                        }
                    });
                });
                
                // Shipping lane blockade - fixed coordinates
                const blockadeCoords = [
                    118.0, 22.0, 122.0, 26.0, 124.0, 24.0, 120.0, 20.0, 118.0, 22.0
                ];
                
                // Validate all coordinates
                const validatedCoords = [];
                for (let i = 0; i < blockadeCoords.length; i += 2) {
                    const coords = this.validateCoordinates(blockadeCoords[i], blockadeCoords[i + 1]);
                    validatedCoords.push(coords.lon, coords.lat);
                }
                
                const blockedShipping = this.viewer.entities.add({
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArray(validatedCoords),
                        width: 10,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.3,
                            color: Cesium.Color.RED
                        }),
                        clampToGround: false,
                        height: 1000
                    }
                });
            }
            
            // HOUR 6: Global Supply Chain Collapse
            hourSix() {
                console.log('üé¨ HOUR 6: Global Supply Chain Collapse');
                this.showVoiceover("HOUR 6: 90% of advanced chips come from here. The world stops.", 6000);
                
                // Pull back to show global shipping routes
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(140, 20, 8000000),
                    5,
                    () => {
                        // Show disrupted shipping routes
                        this.createDisruptedShipping();
                        
                        // Factory shutdowns cascade
                        const factoryShutdowns = [
                            { pos: [139.6917, 35.6895], name: "Toyota halts production", country: "Japan" },
                            { pos: [-83.0458, 42.3314], name: "Ford suspends assembly lines", country: "USA" },
                            { pos: [8.6821, 50.1109], name: "Volkswagen closes plants", country: "Germany" },
                            { pos: [121.4737, 31.2304], name: "Tesla Shanghai offline", country: "China" },
                            { pos: [-122.0322, 37.3230], name: "Apple delays iPhone launch", country: "USA" }
                        ];
                        
                        factoryShutdowns.forEach((shutdown, i) => {
                            setTimeout(() => {
                                this.showAlert(`${shutdown.name} - ${shutdown.country}`, "danger");
                                
                                // Create factory shutdown visualization
                                const factory = this.viewer.entities.add({
                                    position: Cesium.Cartesian3.fromDegrees(shutdown.pos[0], shutdown.pos[1], 0),
                                    ellipse: {
                                        semiMinorAxis: 20000,
                                        semiMajorAxis: 20000,
                                        material: Cesium.Color.ORANGE.withAlpha(0.7),
                                        outline: true,
                                        outlineColor: Cesium.Color.RED
                                    }
                                });
                                
                                // Add smoke effect
                                this.createSmokeEffect(shutdown.pos);
                            }, i * 1500);
                        });
                        
                        setTimeout(() => this.hourTwelve(), 10000);
                    }
                );
            }
            
            // Create disrupted shipping visualization (FIXED)
            createDisruptedShipping() {
                // Major shipping routes now blocked or delayed
                const shippingRoutes = [
                    { 
                        route: [121, 25, 140, 35, 179, 40, -150, 45, -120, 35], // Fixed to avoid 180¬∞ crossing
                        status: "blocked",
                        name: "Trans-Pacific Route"
                    },
                    { 
                        route: [121, 25, 103, 1, 80, 10, 60, 25, 45, 30], 
                        status: "delayed",
                        name: "Asia-Middle East Route"
                    },
                    { 
                        route: [121, 25, 100, -10, 80, -20, 20, -35, 0, 0], 
                        status: "rerouting",
                        name: "Asia-Europe Route"
                    }
                ];
                
                shippingRoutes.forEach(route => {
                    // Validate all coordinates in route
                    const validatedRoute = [];
                    for (let i = 0; i < route.route.length; i += 2) {
                        const coords = this.validateCoordinates(route.route[i], route.route[i + 1]);
                        validatedRoute.push(coords.lon, coords.lat);
                    }
                    
                    const color = route.status === "blocked" ? Cesium.Color.RED :
                                 route.status === "delayed" ? Cesium.Color.ORANGE :
                                 Cesium.Color.YELLOW;
                    
                    const shippingLine = this.viewer.entities.add({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArray(validatedRoute),
                            width: 6,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.2,
                                color: color.withAlpha(0.8)
                            }),
                            clampToGround: false,
                            height: 10000
                        }
                    });
                    
                    // Add animated cargo ships stuck in routes
                    if (route.status === "blocked") {
                        this.createStuckCargoShips(validatedRoute);
                    }
                });
            }
            
            createStuckCargoShips(positions) {
                // Create cargo ships stuck at sea with safe coordinates
                for (let i = 0; i < positions.length - 2; i += 4) {
                    try {
                        // Validate coordinates
                        const coords = this.validateCoordinates(positions[i], positions[i + 1]);
                        
                        const ship = this.createSafeEntity({
                            position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                            rectangle: {
                                coordinates: this.createSafeRectangle(
                                    coords.lon - 0.05, coords.lat - 0.02,
                                    coords.lon + 0.05, coords.lat + 0.02
                                ),
                                material: Cesium.Color.GRAY,
                                height: 0,
                                outline: true,
                                outlineColor: Cesium.Color.WHITE
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to create cargo ship at position ${i}:`, error);
                    }
                }
            }
            
            createSmokeEffect(position) {
                try {
                    // Validate coordinates
                    const coords = this.validateCoordinates(position[0], position[1]);
                    
                    // Industrial smoke/shutdown effect
                    const smokeSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                        image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                        startColor: Cesium.Color.GRAY.withAlpha(0.8),
                        endColor: Cesium.Color.BLACK.withAlpha(0.1),
                        startScale: 20.0,
                        endScale: 50.0,
                        minimumParticleLife: 3.0,
                        maximumParticleLife: 6.0,
                        minimumSpeed: 2.0,
                        maximumSpeed: 8.0,
                        imageSize: new Cesium.Cartesian2(25, 25),
                        emissionRate: 30.0,
                        lifetime: 8.0,
                        emitter: new Cesium.CircleEmitter(5000.0),
                        modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
                            Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 500)
                        )
                    }));
                    
                    // Remove after 8 seconds
                    setTimeout(() => {
                        try {
                            this.viewer.scene.primitives.remove(smokeSystem);
                        } catch (e) {
                            console.warn('Failed to remove smoke system:', e);
                        }
                    }, 8000);
                } catch (error) {
                    console.warn('Failed to create smoke effect:', error);
                }
            }
            
            createFinancialCrisis(position, type) {
                // Validate coordinates
                const coords = this.validateCoordinates(position[0], position[1]);
                
                const colors = {
                    market: Cesium.Color.RED,
                    currency: Cesium.Color.ORANGE,
                    banking: Cesium.Color.PURPLE,
                    central_bank: Cesium.Color.BLUE,
                    controls: Cesium.Color.YELLOW
                };
                
                // Financial crisis visualization
                const crisis = this.viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 1000),
                    ellipse: {
                        semiMinorAxis: 100000,
                        semiMajorAxis: 100000,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const alpha = 0.4 + Math.sin(time * 4) * 0.3;
                                return colors[type].withAlpha(alpha);
                            }, false)
                        ),
                        outline: true,
                        outlineColor: colors[type]
                    }
                });
                
                // Add pulsing effect
                this.createPulsingEffect([coords.lon, coords.lat], colors[type]);
            }
            
            createDataStreamAttack(targetPos) {
                // Validate target coordinates
                const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                
                // Create attack vector lines from various origins
                const attackOrigins = [
                    [116.4074, 39.9042], // Beijing
                    [37.6176, 55.7558],  // Moscow
                    [55.2708, 25.2048]   // Dubai (proxy)
                ];
                
                attackOrigins.forEach(origin => {
                    // Validate origin coordinates
                    const originCoords = this.validateCoordinates(origin[0], origin[1]);
                    
                    const attackVector = this.createSafeEntity({
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                originCoords.lon, originCoords.lat, 20000,
                                targetCoords.lon, targetCoords.lat, 5000
                            ]),
                            width: 4,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.3,
                                color: Cesium.Color.MAGENTA.withAlpha(0.8)
                            })
                        }
                    });
                });
            }
            
            createRefugeeCamp(position) {
                // Validate coordinates and add small offset for camp location
                const coords = this.validateCoordinates(position[0] + 0.1, position[1] + 0.1);
                
                // Refugee camp visualization
                const camp = this.createSafeEntity({
                    position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 0),
                    ellipse: {
                        semiMinorAxis: 15000,
                        semiMajorAxis: 25000,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const alpha = 0.5 + Math.sin(time) * 0.2;
                                return Cesium.Color.BROWN.withAlpha(alpha);
                            }, false)
                        ),
                        outline: true,
                        outlineColor: Cesium.Color.WHITE
                    }
                });
            }
            
            createASATAttack(targetPos) {
                // Anti-satellite weapon launch
                const launchSite = [116.4074, 39.9042, 0]; // China
                
                // Validate launch site coordinates
                const launchCoords = this.validateCoordinates(launchSite[0], launchSite[1]);
                
                // Validate target coordinates (space coordinates don't need validation but we'll be safe)
                const targetCoords = this.validateCoordinates(targetPos[0], targetPos[1]);
                
                // Missile trajectory to satellite
                const asatMissile = this.createSafeEntity({
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                            launchCoords.lon, launchCoords.lat, launchSite[2],
                            targetCoords.lon, targetCoords.lat, targetPos[2]
                        ]),
                        width: 5,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.4,
                            color: Cesium.Color.RED.withAlpha(0.9)
                        })
                    }
                });
                
                // Satellite explosion
                setTimeout(() => {
                    this.createExplosion(
                        Cesium.Cartesian3.fromDegrees(targetCoords.lon, targetCoords.lat, targetPos[2]),
                        0.8
                    );
                }, 2000);
            }
            
            createPulsingEffect(position, color) {
                // Validate coordinates
                const coords = this.validateCoordinates(position[0], position[1]);
                
                const pulseEffect = this.createSafeEntity({
                    position: Cesium.Cartesian3.fromDegrees(coords.lon, coords.lat, 2000),
                    ellipse: {
                        semiMinorAxis: 50000,
                        semiMajorAxis: 50000,
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const scale = 1 + Math.sin(time * 6) * 0.5;
                                const alpha = 0.3 + Math.sin(time * 6) * 0.2;
                                return color.withAlpha(alpha);
                            }, false)
                        )
                    }
                });
                
                // Remove after 5 seconds
                setTimeout(() => {
                    this.viewer.entities.remove(pulseEffect);
                }, 5000);
            }
        }
        
        // Initialize cinematic trailer
        let cinematicTrailer = null;
        
        // Enhanced trailer start function
        function startTrailerSequence() {
            if (!cinematicTrailer) {
                cinematicTrailer = new CinematicTrailerEnhanced(viewer);
            }
            cinematicTrailer.start();
        }
        
        // Notification system
        function showNotification(title, message) {
            const notification = document.getElementById('notification');
            const titleElement = document.getElementById('notificationTitle');
            const textElement = document.getElementById('notificationText');
            
            if (notification && titleElement && textElement) {
                titleElement.textContent = title;
                textElement.textContent = message;
                notification.classList.add('show');
                
            setTimeout(() => {
                    notification.classList.remove('show');
                }, 4000);
            }
        }
        
        // Satellite mode button
        document.getElementById('satelliteModeBtn').addEventListener('click', () => {
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(0, 0, 15000000),
                orientation: {
                    heading: 0,
                    pitch: -Math.PI / 2,
                    roll: 0
                },
                duration: 3
            });
            showNotification('Satellite Mode', 'üõ∞Ô∏è Overhead surveillance view');
        });
        
        // Start loading
        updateLoading();
        
        // COUNTRY DELIMITATIONS AND BORDERS SYSTEM
        class CountryBordersSystem {
            constructor(viewer) {
                this.viewer = viewer;
                this.countryBorders = null;
                this.highlightedCountries = new Map();
                this.allianceColors = {
                    nato: Cesium.Color.BLUE.withAlpha(0.3),
                    pacific: Cesium.Color.GREEN.withAlpha(0.3),
                    neutral: Cesium.Color.YELLOW.withAlpha(0.3),
                    hostile: Cesium.Color.RED.withAlpha(0.3),
                    crisis: Cesium.Color.ORANGE.withAlpha(0.4)
                };
            }
            
            async initialize() {
                console.log('üó∫Ô∏è Loading country borders...');
                
                // Try to load country boundaries from multiple sources
                await this.loadCountryBorders();
                await this.createMajorCountryOutlines();
                
                console.log('‚úÖ Country borders loaded');
            }
            
            async loadCountryBorders() {
                try {
                    // Method 1: Try Natural Earth data (public GeoJSON)
                    const response = await fetch('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson');
                    if (response.ok) {
                        const countryData = await response.json();
                        this.countryBorders = await Cesium.GeoJsonDataSource.load(countryData, {
                            stroke: Cesium.Color.WHITE.withAlpha(0.8),
                            strokeWidth: 2,
                            fill: Cesium.Color.TRANSPARENT,
                            markerSymbol: '?'
                        });
                        this.viewer.dataSources.add(this.countryBorders);
                        return;
                    }
                } catch (error) {
                    console.log('External GeoJSON failed, using manual borders');
                }
                
                // Fallback: Create manual country outlines
                this.createManualCountryBorders();
            }
            
            createManualCountryBorders() {
                // Create major country outlines manually
                const majorCountries = [
                    {
                        name: 'United States',
                        outline: [
                            [-125, 48], [-125, 25], [-80, 25], [-80, 45], [-70, 45], [-70, 48], [-125, 48]
                        ],
                        color: Cesium.Color.WHITE
                    },
                    {
                        name: 'China',
                        outline: [
                            [73, 53], [135, 53], [135, 18], [73, 18], [73, 53]
                        ],
                        color: Cesium.Color.WHITE
                    },
                    {
                        name: 'Russia',
                        outline: [
                            [19, 81], [180, 81], [180, 41], [19, 41], [19, 81]
                        ],
                        color: Cesium.Color.WHITE
                    },
                    {
                        name: 'Europe',
                        outline: [
                            [-10, 71], [40, 71], [40, 35], [-10, 35], [-10, 71]
                        ],
                        color: Cesium.Color.WHITE
                    },
                    {
                        name: 'Japan',
                        outline: [
                            [129, 46], [146, 46], [146, 30], [129, 30], [129, 46]
                        ],
                        color: Cesium.Color.WHITE
                    },
                    {
                        name: 'Taiwan',
                        outline: [
                            [119.5, 25.5], [122, 25.5], [122, 21.5], [119.5, 21.5], [119.5, 25.5]
                        ],
                        color: Cesium.Color.CYAN
                    },
                    {
                        name: 'South Korea',
                        outline: [
                            [125, 39], [130, 39], [130, 33], [125, 33], [125, 39]
                        ],
                        color: Cesium.Color.WHITE
                    },
                    {
                        name: 'Australia',
                        outline: [
                            [113, -10], [154, -10], [154, -44], [113, -44], [113, -10]
                        ],
                        color: Cesium.Color.WHITE
                    },
                    {
                        name: 'India',
                        outline: [
                            [68, 37], [97, 37], [97, 6], [68, 6], [68, 37]
                        ],
                        color: Cesium.Color.WHITE
                    }
                ];
                
                majorCountries.forEach(country => {
                    this.createCountryOutline(country);
                });
            }
            
            createCountryOutline(country) {
                try {
                    // Convert outline to validated coordinates
                    const positions = [];
                    country.outline.forEach(coord => {
                        const validated = this.validateCoordinates(coord[0], coord[1]);
                        positions.push(validated.lon, validated.lat);
                    });
                    
                    const countryEntity = this.viewer.entities.add({
                        name: country.name,
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArray(positions),
                            width: 2,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.1,
                                color: country.color.withAlpha(0.8)
                            }),
                            clampToGround: true
                        }
                    });
                    
                    return countryEntity;
                } catch (error) {
                    console.warn(`Failed to create outline for ${country.name}:`, error);
                }
            }
            
            // Coordinate validation (reuse from main class)
            validateCoordinates(lon, lat) {
                while (lon > 180) lon -= 360;
                while (lon < -180) lon += 360;
                lon = Math.max(-179.99, Math.min(179.99, lon));
                lat = Math.max(-89.99, Math.min(89.99, lat));
                return { lon, lat };
            }
            
            // Highlight specific countries during crisis
            highlightCountry(countryName, alliance, intensity = 0.4) {
                try {
                    const color = this.allianceColors[alliance] || Cesium.Color.WHITE.withAlpha(intensity);
                    
                    // Find and highlight the country
                    const countryData = this.getCountryData(countryName);
                    if (!countryData) return;
                    
                    const highlightEntity = this.viewer.entities.add({
                        name: `${countryName}_highlight`,
                        polygon: {
                            hierarchy: Cesium.Cartesian3.fromDegreesArray(countryData.coordinates),
                            material: color,
                            outline: true,
                            outlineColor: color.brighten(0.3, new Cesium.Color()),
                            height: 1000
                        }
                    });
                    
                    this.highlightedCountries.set(countryName, highlightEntity);
                    return highlightEntity;
                } catch (error) {
                    console.warn(`Failed to highlight ${countryName}:`, error);
                }
            }
            
            getCountryData(countryName) {
                // Simplified country coordinate data
                const countryCoordinates = {
                    'United States': [-125, 25, -80, 25, -80, 48, -125, 48, -125, 25],
                    'China': [73, 18, 135, 18, 135, 53, 73, 53, 73, 18],
                    'Russia': [19, 41, 180, 41, 180, 81, 19, 81, 19, 41],
                    'Taiwan': [119.5, 21.5, 122, 21.5, 122, 25.5, 119.5, 25.5, 119.5, 21.5],
                    'Japan': [129, 30, 146, 30, 146, 46, 129, 46, 129, 30],
                    'South Korea': [125, 33, 130, 33, 130, 39, 125, 39, 125, 33],
                    'Germany': [5.9, 47.3, 15.0, 47.3, 15.0, 55.1, 5.9, 55.1, 5.9, 47.3],
                    'United Kingdom': [-8.6, 49.9, 1.8, 49.9, 1.8, 60.8, -8.6, 60.8, -8.6, 49.9],
                    'France': [-5.1, 42.3, 8.2, 42.3, 8.2, 51.1, -5.1, 51.1, -5.1, 42.3],
                    'Australia': [113, -44, 154, -44, 154, -10, 113, -10, 113, -44],
                    'Philippines': [116, 4, 127, 4, 127, 21, 116, 21, 116, 4],
                    'Turkey': [25.7, 35.8, 44.8, 35.8, 44.8, 42.1, 25.7, 42.1, 25.7, 35.8],
                    'Hungary': [16.1, 45.7, 22.9, 45.7, 22.9, 48.6, 16.1, 48.6, 16.1, 45.7],
                    'Saudi Arabia': [34.5, 16.0, 55.7, 16.0, 55.7, 32.2, 34.5, 32.2, 34.5, 16.0]
                };
                
                const coords = countryCoordinates[countryName];
                if (!coords) return null;
                
                // Validate all coordinates
                const validatedCoords = [];
                for (let i = 0; i < coords.length; i += 2) {
                    const validated = this.validateCoordinates(coords[i], coords[i + 1]);
                    validatedCoords.push(validated.lon, validated.lat);
                }
                
                return { coordinates: validatedCoords };
            }
            
            // Show alliance formations
            showAllianceFormation(allianceName, countries, color) {
                countries.forEach(country => {
                    this.highlightCountry(country, allianceName);
                });
                
                // Add alliance label
                const centerCoord = this.calculateAllianceCenter(countries);
                if (centerCoord) {
                    this.viewer.entities.add({
                        name: `${allianceName}_label`,
                        position: Cesium.Cartesian3.fromDegrees(centerCoord.lon, centerCoord.lat, 100000),
                        label: {
                            text: allianceName.toUpperCase(),
                            font: '18pt bold sans-serif',
                            fillColor: color.brighten(0.5, new Cesium.Color()),
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 3,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            pixelOffset: new Cesium.Cartesian2(0, -50)
                        }
                    });
                }
            }
            
            calculateAllianceCenter(countries) {
                // Simple center calculation for alliance label
                const centers = {
                    'United States': { lon: -100, lat: 40 },
                    'China': { lon: 104, lat: 35 },
                    'Russia': { lon: 100, lat: 60 },
                    'Germany': { lon: 10, lat: 51 },
                    'Japan': { lon: 138, lat: 36 },
                    'United Kingdom': { lon: -2, lat: 54 },
                    'France': { lon: 2, lat: 46 },
                    'Taiwan': { lon: 121, lat: 24 },
                    'South Korea': { lon: 128, lat: 36 },
                    'Australia': { lon: 133, lat: -27 }
                };
                
                if (countries.length === 0) return null;
                
                let totalLon = 0, totalLat = 0;
                let validCount = 0;
                
                countries.forEach(country => {
                    const center = centers[country];
                    if (center) {
                        totalLon += center.lon;
                        totalLat += center.lat;
                        validCount++;
                    }
                });
                
                if (validCount === 0) return null;
                
                return {
                    lon: totalLon / validCount,
                    lat: totalLat / validCount
                };
            }
            
            // Show territorial disputes
            showTerritorialDispute(region, disputingCountries) {
                const disputeRegions = {
                    'Taiwan Strait': {
                        coordinates: [119, 23, 123, 23, 123, 26, 119, 26, 119, 23],
                        center: { lon: 121, lat: 24.5 }
                    },
                    'South China Sea': {
                        coordinates: [99, 0, 121, 0, 121, 23, 99, 23, 99, 0],
                        center: { lon: 110, lat: 12 }
                    },
                    'Korean Peninsula': {
                        coordinates: [125, 33, 130, 33, 130, 43, 125, 43, 125, 33],
                        center: { lon: 127.5, lat: 38 }
                    }
                };
                
                const regionData = disputeRegions[region];
                if (!regionData) return;
                
                // Validate coordinates
                const validatedCoords = [];
                for (let i = 0; i < regionData.coordinates.length; i += 2) {
                    const validated = this.validateCoordinates(regionData.coordinates[i], regionData.coordinates[i + 1]);
                    validatedCoords.push(validated.lon, validated.lat);
                }
                
                // Create dispute zone
                const disputeZone = this.viewer.entities.add({
                    name: `${region}_dispute`,
                    polygon: {
                        hierarchy: Cesium.Cartesian3.fromDegreesArray(validatedCoords),
                        material: new Cesium.ColorMaterialProperty(
                            new Cesium.CallbackProperty(() => {
                                const time = Date.now() / 1000;
                                const alpha = 0.3 + Math.sin(time * 4) * 0.2;
                                return Cesium.Color.RED.withAlpha(alpha);
                            }, false)
                        ),
                        outline: true,
                        outlineColor: Cesium.Color.RED,
                        height: 500
                    }
                });
                
                // Add dispute label
                const center = this.validateCoordinates(regionData.center.lon, regionData.center.lat);
                this.viewer.entities.add({
                    name: `${region}_dispute_label`,
                    position: Cesium.Cartesian3.fromDegrees(center.lon, center.lat, 50000),
                    label: {
                        text: `‚ö†Ô∏è DISPUTED: ${region}`,
                        font: '14pt bold sans-serif',
                        fillColor: Cesium.Color.RED,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        backgroundColor: Cesium.Color.BLACK.withAlpha(0.7),
                        backgroundPadding: new Cesium.Cartesian2(10, 5)
                    }
                });
            }
            
            // Remove all highlights
            clearHighlights() {
                this.highlightedCountries.forEach((entity, countryName) => {
                    try {
                        this.viewer.entities.remove(entity);
                    } catch (error) {
                        console.warn(`Failed to remove highlight for ${countryName}`);
                    }
                });
                this.highlightedCountries.clear();
            }
        }
        
        // Initialize country borders system
        let countryBorders = null;
        
        // Enhanced trailer with country highlighting
        class CinematicTrailerEnhanced extends CinematicTrailer {
            constructor(viewer) {
                super(viewer);
                this.countryBorders = countryBorders;
            }
            
            // Enhanced Hour Zero with country highlighting
            hourZero() {
                console.log('üé¨ ACT I: THE SPARK');
                this.showVoiceover("HOUR 0: Taiwan Strait - A single miscalculation...", 6000);
                
                // Highlight Taiwan and China
                if (this.countryBorders) {
                    this.countryBorders.highlightCountry('Taiwan', 'crisis', 0.6);
                    this.countryBorders.highlightCountry('China', 'hostile', 0.4);
                    this.countryBorders.showTerritorialDispute('Taiwan Strait', ['China', 'Taiwan']);
                }
                
                // Start with peaceful TSMC facilities in Taiwan
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(120.9605, 24.7736, 500000),
                    4,
                    () => {
                        this.createTSMCFacilities();
                        
                        setTimeout(() => {
                            this.showAlert("BREAKING: Chinese naval exercises escalate near Taiwan", "danger");
                            this.showAlert("TSMC halts production at 3nm fabs", "danger");
                            
                            this.createNavalBlockade();
                            
                            setTimeout(() => {
                                this.showAlert("NASDAQ futures down 8% in after-hours trading", "danger");
                                this.showAlert("Apple, NVIDIA trading halted", "danger");
                                setTimeout(() => this.hourSix(), 4000);
                            }, 3000);
                        }, 4000);
                    }
                );
            }
            
            // Enhanced Hour Twelve with alliance highlighting
            hourTwelve() {
                console.log('üé¨ HOUR 12: Economic Warfare & Cyber Attacks');
                this.showVoiceover("HOUR 12: When economics becomes warfare...", 6000);
                
                // Show NATO alliance formation
                if (this.countryBorders) {
                    this.countryBorders.showAllianceFormation('NATO', 
                        ['United States', 'United Kingdom', 'France', 'Germany'], 
                        this.countryBorders.allianceColors.nato
                    );
                }
                
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(-74.006, 40.7128, 2000000),
                    4,
                    () => {
                        const financialAttacks = [
                            { pos: [-74.006, 40.7128], event: "NYSE circuit breakers triggered", type: "market", country: "United States" },
                            { pos: [-0.1276, 51.5074], event: "London: ¬£ crashes to historic low", type: "currency", country: "United Kingdom" },
                            { pos: [139.6917, 35.6895], event: "Tokyo: Bank runs begin", type: "banking", country: "Japan" },
                            { pos: [8.6821, 50.1109], event: "Frankfurt: ECB emergency meeting", type: "central_bank", country: "Germany" },
                            { pos: [121.4737, 31.2304], event: "Shanghai: Capital controls imposed", type: "controls", country: "China" }
                        ];
                        
                        financialAttacks.forEach((attack, i) => {
                            setTimeout(() => {
                                this.showAlert(attack.event, "danger");
                                this.createFinancialCrisis(attack.pos, attack.type);
                                
                                // Highlight affected country
                                if (this.countryBorders && attack.country) {
                                    this.countryBorders.highlightCountry(attack.country, 'crisis', 0.5);
                                }
                                
                                if (i === 2) {
                                    this.createCyberAttackWave();
                                }
                            }, i * 2000);
                        });
                        
                        setTimeout(() => this.hourTwentyFour(), 12000);
                    }
                );
            }
            
            // Enhanced Hour Twenty-Four with alliance fractures
            hourTwentyFour() {
                console.log('üé¨ HOUR 24: Alliance Fractures & Refugee Crisis');
                this.showVoiceover("HOUR 24: When allies become adversaries...", 6000);
                
                this.smoothCameraMove(
                    Cesium.Cartesian3.fromDegrees(10, 50, 6000000),
                    5,
                    () => {
                        // Show alliance fractures with country highlighting
                        const allianceCrises = [
                            { event: "Germany suspends NATO Article 5 compliance", country: "Germany", alliance: "neutral" },
                            { event: "Turkey closes Bosphorus to US ships", country: "Turkey", alliance: "hostile" },
                            { event: "Hungary aligns with China on sanctions", country: "Hungary", alliance: "hostile" },
                            { event: "Philippines revokes US base agreements", country: "Philippines", alliance: "neutral" },
                            { event: "Saudi Arabia accepts yuan for oil", country: "Saudi Arabia", alliance: "hostile" }
                        ];
                        
                        allianceCrises.forEach((crisis, i) => {
                            setTimeout(() => {
                                this.showAlert(crisis.event, "danger");
                                
                                // Highlight country switching sides
                                if (this.countryBorders) {
                                    this.countryBorders.highlightCountry(crisis.country, crisis.alliance, 0.6);
                                }
                            }, i * 1500);
                        });
                        
                        setTimeout(() => {
                            this.createRefugeeCrisis();
                        }, 3000);
                        
                        setTimeout(() => {
                            this.createResourceWars();
                        }, 6000);
                        
                        setTimeout(() => this.hourFortyEight(), 12000);
                    }
                );
            }
        }
        
    </script>
</body>
</html>